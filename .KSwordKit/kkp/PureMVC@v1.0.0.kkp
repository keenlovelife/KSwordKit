//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using System;
using System.Collections.Concurrent;
using PureMVC.Interfaces;
using PureMVC.Patterns.Observer;

namespace PureMVC.Core
{
    /// <summary>
    /// A Multiton <c>IController</c> implementation.
    /// </summary>
    /// <remarks>
    /// 	<para>In PureMVC, the <c>Controller</c> class follows the 
    /// 	'Command and Controller' strategy, and assumes these 
    /// 	responsibilities:</para>
    /// 	<list type="bullet">
    /// 		<item> Remembering which <c>ICommand</c>s 
    /// 		are intended to handle which <c>INotifications</c>.</item>
    /// 		<item> Registering itself as an <c>IObserver</c> with 
    /// 		the <c>View</c> for each <c>INotification</c> 
    /// 		that it has an <c>ICommand</c> mapping for.</item>
    /// 		<item> Creating a new instance of the proper <c>ICommand</c> 
    /// 		to handle a given <c>INotification</c> when notified by the <c>View</c>.</item>
    /// 		<item>Calling the <c>ICommand</c>'s <c>execute</c> 
    /// 		method, passing in the <c>INotification</c>.</item>
    /// 	</list>
    /// 	<para>
    /// 	    Your application must register <c>ICommands</c> with the 
    /// 	    <c>Controller</c>.
    /// 	</para>
    /// 	<para>
    /// 	    The simplest way is to subclass <c>Facade</c>, 
    /// 	    and use its <c>initializeController</c> method to add your 
    /// 	    registrations.
    /// 	</para>
    /// </remarks>
    /// <seealso cref="PureMVC.Core.View"/>
    /// <seealso cref="PureMVC.Patterns.Observer.Observer"/>
    /// <seealso cref="PureMVC.Patterns.Observer.Notification"/>
    /// <seealso cref="PureMVC.Patterns.Command.SimpleCommand"/>
    /// <seealso cref="PureMVC.Patterns.Command.MacroCommand"/>
    public class Controller: IController
    {
        /// <summary>
        /// Constructs and initializes a new controller
        /// </summary>
        /// <remarks>This <c>IController</c> implementation is a Multiton, 
        ///     so you should not call the constructor 
        ///     directly, but instead call the static Multiton
        ///     Factory method <c>Controller.getInstance(multitonKey, () => new Controller(multitonKey))</c>
        /// </remarks>
        /// <param name="key">Key of controller</param>
        /// <exception cref="System.Exception">Thrown if instance for this Multiton key has already been constructed</exception>
        public Controller(string key)
        {
            if (instanceMap.TryGetValue(key, out Lazy<IController> _) && multitonKey != null) throw new Exception(MULTITON_MSG);
            multitonKey = key;
            instanceMap.TryAdd(multitonKey, new Lazy<IController>(() => this));
            commandMap = new ConcurrentDictionary<string, Func<ICommand>>();
            InitializeController();
        }

        /// <summary>
        /// Initialize the Multiton <c>Controller</c> instance
        /// </summary>
        /// <remarks>
        ///     <para>Called automatically by the constructor</para>
        ///     <para>
        ///         Please aware that if you are using a subclass of <c>View</c>
        ///         in your application, you should also subclass <c>Controller</c>
        ///         and override the <c>initializeController</c> method in the following way:
        ///     </para>
        ///     <example>
        ///         <code>
        ///             // ensure that the Controller is talking to my IView implementation
        ///             public override void initializeController()
        ///             {
        ///                 view = MyView.getInstance(multitonKey, () => new MyView(multitonKey));
        ///             }
        ///         </code>
        ///     </example>
        /// </remarks>
        protected virtual void InitializeController()
        {
            view = View.GetInstance(multitonKey, () => new View(multitonKey));
        }

        /// <summary>
        /// <c>Controller</c> Multiton Factory method.
        /// </summary>
        /// <param name="key">Key of controller</param>
        /// <param name="controllerClassRef">the <c>FuncDelegate</c> of the <c>IController</c></param>
        /// <returns>the Multiton instance of <c>Controller</c></returns>
        public static IController GetInstance(string key, Func<IController> controllerClassRef)
        {
            return instanceMap.GetOrAdd(key, (k) => new Lazy<IController>(controllerClassRef)).Value;
        }

        /// <summary>
        /// If an <c>ICommand</c> has previously been registered 
        /// to handle a the given <c>INotification</c>, then it is executed.
        /// </summary>
        /// <param name="notification">note an <c>INotification</c></param>
        public virtual void ExecuteCommand(INotification notification)
        {
            if (commandMap.TryGetValue(notification.Name, out Func<ICommand> commandClassRef))
            {
                ICommand commandInstance = commandClassRef();
                commandInstance.InitializeNotifier(multitonKey);
                commandInstance.Execute(notification);
            }
        }

        /// <summary>
        /// Register a particular <c>ICommand</c> class as the handler 
        /// for a particular <c>INotification</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         If a <c>ICommand</c> has already been registered to 
        ///         handle <c>INotification</c>s with this name, it is no longer
        ///         used, the new <c>Func</c> is used instead.
        ///     </para>
        ///     <para>
        ///         The Observer for the new ICommand is only created if this the
        ///         first time an ICommand has been regisered for this Notification name.
        ///     </para>
        /// </remarks>
        /// <param name="notificationName">the name of the <c>INotification</c></param>
        /// <param name="commandClassRef">the <c>Func Delegate</c> of the <c>ICommand</c></param>
        public virtual void RegisterCommand(string notificationName, Func<ICommand> commandClassRef)
        {
            if (commandMap.TryGetValue(notificationName, out Func<ICommand> _) == false)
            {
                view.RegisterObserver(notificationName, new Observer(ExecuteCommand, this));
            }
            commandMap[notificationName] = commandClassRef;
        }

        /// <summary>
        /// Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping.
        /// </summary>
        /// <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        public virtual void RemoveCommand(string notificationName)
        {
            if (commandMap.TryRemove(notificationName, out Func<ICommand> _))
            {
                view.RemoveObserver(notificationName, this);
            }
        }

        /// <summary>
        /// Check if a Command is registered for a given Notification 
        /// </summary>
        /// <param name="notificationName"></param>
        /// <returns>whether a Command is currently registered for the given <c>notificationName</c>.</returns>
        public virtual bool HasCommand(string notificationName)
        {
            return commandMap.ContainsKey(notificationName);
        }

        /// <summary>
        /// Remove an IController instance
        /// </summary>
        /// <param name="key">multitonKey of IController instance to remove</param>
        public static void RemoveController(string key)
        {
            instanceMap.TryRemove(key, out Lazy<IController> _);
        }

        /// <summary>Local reference to View</summary>
        protected IView view;

        /// <summary>The Multiton Key for this Core</summary>
        protected string multitonKey;

        /// <summary>Mapping of Notification names to Command Class references</summary>
        protected ConcurrentDictionary<string, Func<ICommand>> commandMap;
        
        /// <summary>The Multiton Controller instanceMap.</summary>
        protected static ConcurrentDictionary<string, Lazy<IController>> instanceMap = new ConcurrentDictionary<string, Lazy<IController>>();

        /// <summary>Message Constants</summary>
        protected const string MULTITON_MSG = "Controller instance for this Multiton key already constructed!";
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using System;
using System.Collections.Concurrent;
using PureMVC.Interfaces;

namespace PureMVC.Core
{
    /// <summary>
    /// A Multiton <c>IModel</c> implementation
    /// </summary>
    /// <remarks>
    ///     <para>In PureMVC, the <c>Model</c> class provides access to model objects (Proxies) by named lookup</para>
    ///     <para>The <c>Model</c> assumes these responsibilities:</para>
    ///     <list type="bullet">
    ///         <item>Maintain a cache of <c>IProxy</c> instances</item>
    ///         <item>Provide methods for registering, retrieving, and removing <c>IProxy</c> instances</item>
    ///     </list>
    ///     <para>
    ///         Your application must register <c>IProxy</c> instances
    ///         with the <c>Model</c>. Typically, you use an 
    ///         <c>ICommand</c> to create and register <c>IProxy</c> 
    ///         instances once the <c>Facade</c> has initialized the Core actors
    ///     </para>
    /// </remarks>
    /// <seealso cref="PureMVC.Patterns.Proxy.Proxy"/>
    /// <seealso cref="PureMVC.Interfaces.IProxy" />
    public class Model: IModel
    {
        /// <summary>
        /// Constructs and initializes a new model
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         This <c>IModel</c> implementation is a Multiton, 
        ///         so you should not call the constructor 
        ///         directly, but instead call the static Multiton 
        ///         Factory method <c>Model.getInstance(multitonKey, () => new Model(multitonKey))</c>
        ///     </para>
        /// </remarks>
        /// <param name="key">Key of model</param>
        /// <exception cref="System.Exception">Thrown if instance for this Multiton key has already been constructed</exception>
        public Model(string key)
        {
            if (instanceMap.ContainsKey(key) && multitonKey != null) throw new Exception(MULTITON_MSG);
            multitonKey = key;
            instanceMap.TryAdd(key, new Lazy<IModel>(() => this));
            proxyMap = new ConcurrentDictionary<string, IProxy>();
            InitializeModel();
        }

        /// <summary>
        /// Initialize the Multiton <c>Model</c> instance.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Called automatically by the constructor, this 
        ///         is your opportunity to initialize the Multiton 
        ///         instance in your subclass without overriding the 
        ///         constructor
        ///     </para>
        /// </remarks>
        protected virtual void InitializeModel()
        {
        }

        /// <summary>
        /// <c>Model</c> Multiton Factory method. 
        /// </summary>
        /// <param name="key">Key of model</param>
        /// <param name="modelClassRef">the <c>FuncDelegate</c> of the <c>IModel</c></param>
        /// <returns>the instance for this Multiton key </returns>
        public static IModel GetInstance(string key, Func<IModel> modelClassRef)
        {
            return instanceMap.GetOrAdd(key, new Lazy<IModel>(modelClassRef)).Value;
        }

        /// <summary>
        /// Register an <c>IProxy</c> with the <c>Model</c>.
        /// </summary>
        /// <param name="proxy">proxy an <c>IProxy</c> to be held by the <c>Model</c>.</param>
        public virtual void RegisterProxy(IProxy proxy)
        {
            proxy.InitializeNotifier(multitonKey);
            proxyMap[proxy.ProxyName] = proxy;
            proxy.OnRegister();
        }

        /// <summary>
        /// Retrieve an <c>IProxy</c> from the <c>Model</c>.
        /// </summary>
        /// <param name="proxyName"></param>
        /// <returns>the <c>IProxy</c> instance previously registered with the given <c>proxyName</c>.</returns>
        public virtual IProxy RetrieveProxy(string proxyName)
        {
            return proxyMap.TryGetValue(proxyName, out IProxy proxy) ? proxy : null;
        }

        /// <summary>
        /// Remove an <c>IProxy</c> from the <c>Model</c>.
        /// </summary>
        /// <param name="proxyName">proxyName name of the <c>IProxy</c> instance to be removed.</param>
        /// <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        public virtual IProxy RemoveProxy(string proxyName)
        {
            if (proxyMap.TryRemove(proxyName, out IProxy proxy))
            {
                proxy.OnRemove();
            }
            return proxy;
        }

        /// <summary>
        /// Check if a Proxy is registered
        /// </summary>
        /// <param name="proxyName"></param>
        /// <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        public virtual bool HasProxy(string proxyName)
        {
            return proxyMap.ContainsKey(proxyName);
        }

        /// <summary>
        /// Remove an IModel instance
        /// </summary>
        /// <param name="key">multitonKey of IModel instance to remove</param>
        public static void RemoveModel(string key)
        {
            instanceMap.TryRemove(key, out Lazy<IModel> _);
        }

        /// <summary>The Multiton Key for this Core</summary>
        protected string multitonKey;

        /// <summary>Mapping of proxyNames to IProxy instances</summary>
        protected readonly ConcurrentDictionary<string, IProxy> proxyMap;

        /// <summary>The Multiton Model instanceMap.</summary>
        protected static readonly ConcurrentDictionary<string, Lazy<IModel>> instanceMap = new ConcurrentDictionary<string, Lazy<IModel>>();

        /// <summary>Message Constants</summary>
        protected const string MULTITON_MSG = "Model instance for this Multiton key already constructed!";
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using PureMVC.Interfaces;
using PureMVC.Patterns.Observer;

namespace PureMVC.Core
{
    /// <summary>
    /// A Multiton <c>IView</c> implementation.
    /// </summary>
    /// <remarks>
    ///     <para>In PureMVC, the <c>View</c> class assumes these responsibilities:</para>
    ///     <list type="bullet">
    ///         <item>Maintain a cache of <c>IMediator</c> instances</item>
    ///         <item>Provide methods for registering, retrieving, and removing <c>IMediators</c></item>
    ///         <item>Managing the observer lists for each <c>INotification</c> in the application</item>
    ///         <item>Providing a method for attaching <c>IObservers</c> to an <c>INotification</c>'s observer list</item>
    ///         <item>Providing a method for broadcasting an <c>INotification</c></item>
    ///         <item>Notifying the <c>IObservers</c> of a given <c>INotification</c> when it broadcast</item>
    ///     </list>
    /// </remarks>
    /// <seealso cref="PureMVC.Patterns.Mediator.Mediator"/>
    /// <seealso cref="PureMVC.Patterns.Observer.Observer"/>
    /// <seealso cref="PureMVC.Patterns.Observer.Notification"/>
    public class View: IView
    {
        /// <summary>
        /// Constructs and initializes a new view
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         This <c>IView</c> implementation is a Multiton, 
        ///         so you should not call the constructor 
        ///         directly, but instead call the static Multiton 
        ///         Factory method <c>View.getInstance(multitonKey, () => new View(multitonKey))</c>
        ///     </para>
        /// </remarks>
        /// <param name="key">Key of view</param>
        /// <exception cref="System.Exception">Thrown if instance for this Multiton key has already been constructed</exception>
        public View(string key)
        {
            if (instanceMap.TryGetValue(key, out Lazy<IView> _) && multitonKey != null) throw new Exception(MULTITON_MSG);
            multitonKey = key;
            instanceMap.TryAdd(key, new Lazy<IView>(() => this));
            mediatorMap = new ConcurrentDictionary<string, IMediator>();
            observerMap = new ConcurrentDictionary<string, IList<IObserver>>();
            InitializeView();
        }

        /// <summary>
        /// Initialize the Multiton View instance.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Called automatically by the constructor, this
        ///         is your opportunity to initialize the Multiton
        ///         instance in your subclass without overriding the
        ///         constructor.
        ///     </para>
        /// </remarks>
        protected virtual void InitializeView()
        {
        }

        /// <summary>
        /// <c>View</c> Multiton Factory method. 
        /// </summary>
        /// <param name="key">Key of view</param>
        /// <param name="viewClassRef">the <c>FuncDelegate</c> of the <c>IView</c></param>
        /// <returns>the instance for this Multiton key </returns>
        public static IView GetInstance(string key, Func<IView> viewClassRef)
        {
            return instanceMap.GetOrAdd(key, new Lazy<IView>(viewClassRef)).Value;
        }

        /// <summary>
        ///     Register an <c>IObserver</c> to be notified
        ///     of <c>INotifications</c> with a given name.
        /// </summary>
        /// <param name="notificationName">the name of the <c>INotifications</c> to notify this <c>IObserver</c> of</param>
        /// <param name="observer">the <c>IObserver</c> to register</param>
        public virtual void RegisterObserver(string notificationName, IObserver observer)
        {
            if (observerMap.TryGetValue(notificationName, out IList<IObserver> observers))
            {
                observers.Add(observer);
            }
            else
            {
                observerMap.TryAdd(notificationName, new List<IObserver> { observer });
            }
        }

        /// <summary>
        /// Notify the <c>IObservers</c> for a particular <c>INotification</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         All previously attached <c>IObservers</c> for this <c>INotification</c>'s
        ///         list are notified and are passed a reference to the <c>INotification</c> in
        ///         the order in which they were registered.
        ///     </para>
        /// </remarks>
        /// <param name="notification"></param>
        public virtual void NotifyObservers(INotification notification)
        {
            // Get a reference to the observers list for this notification name
            if (observerMap.TryGetValue(notification.Name, out IList<IObserver> observers_ref))
            {
                // Copy observers from reference array to working array, 
                // since the reference array may change during the notification loop
                var observers = new List<IObserver>(observers_ref);
                foreach (IObserver observer in observers)
                {
                    observer.NotifyObserver(notification);
                }
            }
        }

        /// <summary>
        /// Remove the observer for a given notifyContext from an observer list for a given Notification name.
        /// </summary>
        /// <param name="notificationName">which observer list to remove from </param>
        /// <param name="notifyContext">remove the observer with this object as its notifyContext</param>
        public virtual void RemoveObserver(string notificationName, object notifyContext)
        {
            if (observerMap.TryGetValue(notificationName, out IList<IObserver> observers))
            {
                for (int i = 0; i < observers.Count; i++)
                {
                    if (observers[i].CompareNotifyContext(notifyContext))
                    {
                        observers.RemoveAt(i);
                        break;
                    }
                }

                // Also, when a Notification's Observer list length falls to
                // zero, delete the notification key from the observer map
                if (observers.Count == 0)
                    observerMap.TryRemove(notificationName, out IList<IObserver> _);
            }
        }

        /// <summary>
        /// Register an <c>IMediator</c> instance with the <c>View</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Registers the <c>IMediator</c> so that it can be retrieved by name,
        ///         and further interrogates the <c>IMediator</c> for its 
        ///         <c>INotification</c> interests.
        ///     </para>
        ///     <para>
        ///         If the <c>IMediator</c> returns any <c>INotification</c>
        ///         names to be notified about, an <c>Observer</c> is created encapsulating 
        ///         the <c>IMediator</c> instance's <c>handleNotification</c> method 
        ///         and registering it as an <c>Observer</c> for all <c>INotifications</c> the
        ///         <c>IMediator</c> is interested in.
        ///     </para>
        /// </remarks>
        /// <param name="mediator">the name to associate with this <c>IMediator</c> instance</param>
        public virtual void RegisterMediator(IMediator mediator)
        {
            if(mediatorMap.TryAdd(mediator.MediatorName, mediator))
            {
                mediator.InitializeNotifier(multitonKey);

                string[] interests = mediator.ListNotificationInterests();

                if (interests.Length > 0)
                {
                    IObserver observer = new Observer(mediator.HandleNotification, mediator);
                    for (int i = 0; i < interests.Length; i++)
                    {
                        RegisterObserver(interests[i], observer);
                    }
                }
                // alert the mediator that it has been registered
                mediator.OnRegister();
            }
        }

        /// <summary>
        /// Retrieve an <c>IMediator</c> from the <c>View</c>.
        /// </summary>
        /// <param name="mediatorName">the name of the <c>IMediator</c> instance to retrieve.</param>
        /// <returns>the <c>IMediator</c> instance previously registered with the given <c>mediatorName</c>.</returns>
        public virtual IMediator RetrieveMediator(string mediatorName)
        {
            return mediatorMap.TryGetValue(mediatorName, out IMediator mediator) ? mediator : null;
        }

        /// <summary>
        /// Remove an <c>IMediator</c> from the <c>View</c>.
        /// </summary>
        /// <param name="mediatorName">name of the <c>IMediator</c> instance to be removed.</param>
        /// <returns>the <c>IMediator</c> that was removed from the <c>View</c></returns>
        public virtual IMediator RemoveMediator(string mediatorName)
        {
            if (mediatorMap.TryRemove(mediatorName, out IMediator mediator))
            {
                string[] interests = mediator.ListNotificationInterests();
                for (int i = 0; i < interests.Length; i++)
                {
                    RemoveObserver(interests[i], mediator);
                }
                mediator.OnRemove();
            }
            return mediator;
        }

        /// <summary>
        /// Check if a Mediator is registered or not
        /// </summary>
        /// <param name="mediatorName"></param>
        /// <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        public virtual bool HasMediator(string mediatorName)
        {
            return mediatorMap.ContainsKey(mediatorName);
        }

        /// <summary>
        /// Remove an IView instance
        /// </summary>
        /// <param name="key">multitonKey of IView instance to remove</param>
        public static void RemoveView(string key)
        {
            instanceMap.TryRemove(key, out Lazy<IView> _);
        }

        /// <summary>The Multiton Key for this Core</summary>
        protected string multitonKey;

        /// <summary>Mapping of Mediator names to Mediator instances</summary>
        protected ConcurrentDictionary<string, IMediator> mediatorMap;

        /// <summary>Mapping of Notification names to Observer lists</summary>
        protected ConcurrentDictionary<string, IList<IObserver>> observerMap;

        /// <summary>The Multiton View instanceMap.</summary>
        protected static ConcurrentDictionary<string, Lazy<IView>> instanceMap = new ConcurrentDictionary<string, Lazy<IView>>();

        /// <summary>Message Constants</summary>
        protected const string MULTITON_MSG = "View instance for this Multiton key already constructed!";
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

namespace PureMVC.Interfaces
{
    /// <summary>
    /// The interface definition for a PureMVC Command.
    /// </summary>
    /// <seealso cref="INotification"/>
    public interface ICommand: INotifier
    {
        /// <summary>
        /// Execute the <c>ICommand</c>'s logic to handle a given <c>INotification</c>.
        /// </summary>
        /// <param name="Notification">an <c>INotification</c> to handle.</param>
        void Execute(INotification Notification);
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using System;

namespace PureMVC.Interfaces
{
    /// <summary>
    /// The interface definition for a PureMVC Controller.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         In PureMVC, an <c>IController</c> implementor 
    ///         follows the 'Command and Controller' strategy, and 
    ///         assumes these responsibilities:
    ///         <list type="bullet">
    ///             <item>Remembering which <c>ICommand</c>s 
    ///             are intended to handle which <c>INotifications</c>.
    ///             </item>
    ///             <item>Registering itself as an <c>IObserver</c> with
    ///             the <c>View</c> for each <c>INotification</c> 
    ///             that it has an <c>ICommand</c> mapping for.
    ///             </item>
    ///             <item>Creating a new instance of the proper <c>ICommand</c> 
    ///             to handle a given <c>INotification</c> when notified by the <c>View</c>.
    ///             </item>
    ///             <item>Calling the <c>ICommand</c>'s <c>execute</c> 
    ///             method, passing in the <c>INotification</c>.
    ///             </item>
    ///         </list>
    ///     </para>
    /// </remarks>
    /// <seealso cref="INotification"/>
    /// <seealso cref="ICommand"/>
    public interface IController
    {
        /// <summary>
        /// Register a particular <c>ICommand</c> class as the handler 
        ///  for a particular <c>INotification</c>.
        /// </summary>
        /// <param name="notificationName">the name of the <c>INotification</c></param>
        /// <param name="commandClassRef">the FuncDelegate of the <c>ICommand</c></param>
        void RegisterCommand(string notificationName, Func<ICommand> commandClassRef);

        /// <summary>
        /// Execute the <c>ICommand</c> previously registered as the
        /// handler for <c>INotification</c>s with the given notification name.
        /// </summary>
        /// <param name="notification">the <c>INotification</c> to execute the associated <c>ICommand</c> for</param>
        void ExecuteCommand(INotification notification);

        /// <summary>
        /// Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping.
        /// </summary>
        /// <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        void RemoveCommand(string notificationName);

        /// <summary>
        /// Check if a Command is registered for a given Notification 
        /// </summary>
        /// <param name="notificationName">whether a Command is currently registered for the given <c>notificationName</c>.</param>
        /// <returns></returns>
        bool HasCommand(string notificationName);
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using System;

namespace PureMVC.Interfaces
{
    /// <summary>
    /// The interface definition for a PureMVC Facade.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         The Facade Pattern suggests providing a single
    ///         class to act as a central point of communication 
    ///         for a subsystem.
    ///     </para>
    ///     <para>
    ///         In PureMVC, the Facade acts as an interface between
    ///         the Core MVC actors (Model, View, Controller) and
    ///         the rest of your application.
    ///     </para>
    /// </remarks>
    /// <seealso cref="IModel"/>
    /// <seealso cref="IView"/>
    /// <seealso cref="IController"/>
    /// <seealso cref="ICommand"/>
    /// <seealso cref="INotification"/>
    public interface IFacade: INotifier
    {
        /// <summary>
        /// Register an <c>IProxy</c> with the <c>Model</c> by name.
        /// </summary>
        /// <param name="proxy">the <c>IProxy</c> to be registered with the <c>Model</c>.</param>
        void RegisterProxy(IProxy proxy);

        /// <summary>
        /// Retrieve a <c>IProxy</c> from the <c>Model</c> by name.
        /// </summary>
        /// <param name="proxyName">the name of the <c>IProxy</c> instance to be retrieved.</param>
        /// <returns>the <c>IProxy</c> previously regisetered by <c>proxyName</c> with the <c>Model</c>.</returns>
        IProxy RetrieveProxy(string proxyName);

        /// <summary>
        /// Remove an <c>IProxy</c> instance from the <c>Model</c> by name.
        /// </summary>
        /// <param name="proxyName">the <c>IProxy</c> to remove from the <c>Model</c>.</param>
        /// <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        IProxy RemoveProxy(string proxyName);

        /// <summary>
        /// Check if a Proxy is registered
        /// </summary>
        /// <param name="proxyName"></param>
        /// <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        bool HasProxy(string proxyName);

        /// <summary>
        /// Register an <c>ICommand</c> with the <c>Controller</c>.
        /// </summary>
        /// <param name="notificationName">the name of the <c>INotification</c> to associate the <c>ICommand</c> with.</param>
        /// <param name="commandClassRef">a reference to the <c>FuncDelegate</c> of the <c>ICommand</c></param>
        void RegisterCommand(string notificationName, Func<ICommand> commandClassRef);

        /// <summary>
        /// Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping from the Controller.
        /// </summary>
        /// <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        void RemoveCommand(string notificationName);

        /// <summary>
        /// Check if a Command is registered for a given Notification 
        /// </summary>
        /// <param name="notificationName"></param>
        /// <returns>whether a Command is currently registered for the given <c>notificationName</c>.</returns>
        bool HasCommand(string notificationName);

        /// <summary>
        /// Register an <c>IMediator</c> instance with the <c>View</c>.
        /// </summary>
        /// <param name="mediator">a reference to the <c>IMediator</c> instance</param>
        void RegisterMediator(IMediator mediator);

        /// <summary>
        /// Retrieve an <c>IMediator</c> instance from the <c>View</c>.
        /// </summary>
        /// <param name="mediatorName">the name of the <c>IMediator</c> instance to retrievve</param>
        /// <returns>the <c>IMediator</c> previously registered with the given <c>mediatorName</c>.</returns>
        IMediator RetrieveMediator(string mediatorName);

        /// <summary>
        /// Remove a <c>IMediator</c> instance from the <c>View</c>.
        /// </summary>
        /// <param name="mediatorName">name of the <c>IMediator</c> instance to be removed</param>
        /// <returns>the <c>IMediator</c> instance previously registered with the given <c>mediatorName</c>.</returns>
        IMediator RemoveMediator(string mediatorName);

        /// <summary>
        /// Check if a Mediator is registered or not
        /// </summary>
        /// <param name="mediatorName"></param>
        /// <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        bool HasMediator(string mediatorName);

        /// <summary>
        /// Notify <c>Observer</c>s.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         This method is left public mostly for backward 
        ///         compatibility, and to allow you to send custom 
        ///         notification classes using the facade.
        ///     </para>
        ///     <para>
        ///         Usually you should just call sendNotification
        ///         and pass the parameters, never having to 
        ///         construct the notification yourself.
        ///     </para>
        /// </remarks>
        /// <param name="notification">the <c>INotification</c> to have the <c>View</c> notify <c>Observers</c> of.</param>
        void NotifyObservers(INotification notification);
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

namespace PureMVC.Interfaces
{
    /// <summary>
    /// The interface definition for a PureMVC Mediator.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         In PureMVC, <c>IMediator</c> implementors assume these responsibilities:
    ///         <list type="bullet">
    ///             <item>Implement a common method which returns a list of all <c>INotification</c>s
    ///             the <c>IMediator</c> has interest in.</item>
    ///             <item>Implement a notification callback method.</item>
    ///             <item>Implement methods that are called when the IMediator is registered or removed from the View</item>
    ///         </list>
    ///     </para>
    ///     <para>
    ///         Additionally, <c>IMediator</c>s typically:
    ///         <list type="bullet">
    ///             <item>Act as an intermediary between one or more view components such as text boxes or 
    ///             list controls, maintaining references and coordinating their behavior.</item>
    ///             <item>In Flash-based apps, this is often the place where event listeners are
    ///             added to view components, and their handlers implemented.</item>
    ///             <item>Respond to and generate <c>INotifications</c>, interacting with of
    ///             the rest of the PureMVC app.</item>
    ///         </list>
    ///     </para>
    ///     <para>
    ///         When an <c>IMediator</c> is registered with the <c>IView</c>, 
    ///         the <c>IView</c> will call the <c>IMediator</c>'s 
    ///         <c>listNotificationInterests</c> method. The <c>IMediator</c> will 
    ///         return an <c>Array</c> of <c>INotification</c> names which 
    ///         it wishes to be notified about.
    ///     </para>
    ///     <para>
    ///         The <c>IView</c> will then create an <c>Observer</c> object 
    ///         encapsulating that <c>IMediator</c>'s (<c>handleNotification</c>) method
    ///         and register it as an Observer for each <c>INotification</c> name returned by 
    ///         <c>listNotificationInterests</c>.
    ///     </para>
    /// </remarks>
    /// <seealso cref="INotification"/>
    public interface IMediator: INotifier
    {
        /// <summary>
        /// Get or Set the <c>IMediator</c> instance name
        /// </summary>
        string MediatorName { get; }

        /// <summary>
        /// Get or Set the <c>IMediator</c>'s view component.
        /// </summary>
        object ViewComponent { get; set; }

        /// <summary>
        /// List <c>INotification</c> interests.
        /// </summary>
        /// <returns> an <c>Array</c> of the <c>INotification</c> names this <c>IMediator</c> has an interest in.</returns>
        string[] ListNotificationInterests();

        /// <summary>
        /// Handle an <c>INotification</c>.
        /// </summary>
        /// <param name="notification">notification the <c>INotification</c> to be handled</param>
        void HandleNotification(INotification notification);

        /// <summary>
        /// Called by the View when the Mediator is registered
        /// </summary>
        void OnRegister();

        /// <summary>
        /// Called by the View when the Mediator is removed
        /// </summary>
        void OnRemove();
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

namespace PureMVC.Interfaces
{
    /// <summary>
    /// The interface definition for a PureMVC Model.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         In PureMVC, <c>IModel</c> implementors provide
    ///         access to <c>IProxy</c> objects by named lookup.
    ///     </para>
    ///     <para>
    ///         An <c>IModel</c> assumes these responsibilities:
    ///         <list type="bullet">
    ///             <item>Maintain a cache of <c>IProxy</c> instances</item>
    ///             <item>Provide methods for registering, retrieving, and removing <c>IProxy</c> instances</item>
    ///         </list>
    ///     </para>
    /// </remarks>
    public interface IModel
    {
        /// <summary>
        /// Register an <c>IProxy</c> instance with the <c>Model</c>.
        /// </summary>
        /// <param name="proxy">an object reference to be held by the <c>Model</c>.</param>
        void RegisterProxy(IProxy proxy);

        /// <summary>
        /// Retrieve an <c>IProxy</c> instance from the Model.
        /// </summary>
        /// <param name="proxyName"></param>
        /// <returns>the <c>IProxy</c> instance previously registered with the given <c>proxyName</c>.</returns>
        IProxy RetrieveProxy(string proxyName);

        /// <summary>
        /// Remove an <c>IProxy</c> instance from the Model.
        /// </summary>
        /// <param name="proxyName"></param>
        /// <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        IProxy RemoveProxy(string proxyName);

        /// <summary>
        /// Check if a Proxy is registered
        /// </summary>
        /// <param name="proxyName"></param>
        /// <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        bool HasProxy(string proxyName);
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

namespace PureMVC.Interfaces
{
    /// <summary>
    /// A base <c>INotification</c> implementation.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         PureMVC does not rely upon underlying event models such 
    ///         as the one provided with Flash, and ActionScript 3 does 
    ///         not have an inherent event model.
    ///     </para>
    ///     <para>
    ///         The Observer Pattern as implemented within PureMVC exists 
    ///         to support event-driven communication between the 
    ///         application and the actors of the MVC triad.
    ///     </para>
    ///     <para>
    ///         Notifications are not meant to be a replacement for Events
    ///         in Flex/Flash/Apollo. Generally, <c>IMediator</c> implementors
    ///         place event listeners on their view components, which they
    ///         then handle in the usual way. This may lead to the broadcast of <c>Notification</c>s to 
    ///         trigger <c>ICommand</c>s or to communicate with other <c>IMediators</c>. 
    ///         <c>IProxy</c> and <c>ICommand</c>
    ///         instances communicate with each other and <c>IMediator</c>s
    ///         by broadcasting <c>INotification</c>s.
    ///     </para>
    ///     <para>
    ///         A key difference between Flash <c>Event</c>s and PureMVC
    ///         <c>Notification</c>s is that <c>Event</c>s follow the 
    ///         'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy 
    ///         until some parent component handles the <c>Event</c>, while
    ///         PureMVC <c>Notification</c>s follow a 'Publish/Subscribe'
    ///         pattern. PureMVC classes need not be related to each other in a 
    ///         parent/child relationship in order to communicate with one another
    ///         using <c>Notification</c>s.
    ///     </para>
    /// </remarks>
    /// <seealso cref="IView"/>
    /// <seealso cref="IObserver"/>
    public interface INotification
    {
        /// <summary>
        /// Get the name of the <c>INotification</c> instance. 
        /// No setter, should be set by constructor only
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Get or Set the body of the <c>INotification</c> instance
        /// </summary>
        object Body { get; set; }

        /// <summary>
        /// Get or Set the type of the <c>INotification</c> instance
        /// </summary>
        string Type { get; set; }

        /// <summary>
        /// Get the string representation of the <c>INotification</c> instance
        /// </summary>
        /// <returns>String representation</returns>
        string ToString();
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

namespace PureMVC.Interfaces
{
    /// <summary>
    /// A Base <c>INotifier</c> implementation.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         <c>MacroCommand, Command, Mediator</c> and <c>Proxy</c> 
    ///         all have a need to send <c>Notifications</c>.
    ///     </para>
    ///     <para>
    ///         The <c>INotifier</c> interface provides a common method called
    ///         <c>sendNotification</c> that relieves implementation code of 
    ///         the necessity to actually construct <c>Notifications</c>.
    ///     </para>
    ///     <para>
    ///         The <c>Notifier</c> class, which all of the above mentioned classes
    ///         extend, provides an initialized reference to the <c>Facade</c>
    ///         Multiton, which is required for the convienience method
    ///         for sending <c>Notifications</c>, but also eases implementation as these
    ///         classes have frequent <c>Facade</c> interactions and usually require
    ///         access to the facade anyway.
    ///     </para>
    /// </remarks>
    /// <seealso cref="IFacade"/>
    /// <seealso cref="INotification"/>
    public interface INotifier
    {
        /// <summary>
        /// Send a <c>INotification</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Convenience method to prevent having to construct new 
        ///         notification instances in our implementation code.
        ///     </para>
        /// </remarks>
        /// <param name="notificationName">the name of the notification to send</param>
        /// <param name="body">the body of the notification (optional)</param>
        /// <param name="type">the type of the notification (optional)</param>
        void SendNotification(string notificationName, object body = null, string type = null);

        /// <summary>
        /// Initialize this INotifier instance.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         This is how a Notifier gets its multitonKey. 
        ///         Calls to sendNotification or to access the
        ///         facade will fail until after this method 
        ///         has been called.
        ///     </para>
        /// </remarks>
        /// <param name="key">the multitonKey for this INotifier to use</param>
        void InitializeNotifier(string key);
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using System;

namespace PureMVC.Interfaces
{
    /// <summary>
    /// The interface definition for a PureMVC Observer.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         In PureMVC, the <c>Observer</c> class assumes these responsibilities:
    ///         <list type="bullet">
    ///             <item>Encapsulate the notification (callback) method of the interested object.</item>
    ///             <item>Encapsulate the notification context (this) of the interested object.</item>
    ///             <item>Provide methods for setting the notification method and context.</item>
    ///             <item>Provide a method for notifying the interested object.</item>
    ///         </list>
    ///     </para>
    ///     <para>
    ///         PureMVC does not rely upon underlying event models such 
    ///         as the one provided with Flash, and ActionScript 3 does 
    ///         not have an inherent event model.
    ///     </para>
    ///     <para>
    ///         The Observer Pattern as implemented within PureMVC exists 
    ///         to support event-driven communication between the 
    ///         application and the actors of the MVC triad.
    ///     </para>
    ///     <para>
    ///         An Observer is an object that encapsulates information
    ///         about an interested object with a notification method that
    ///         should be called when an <c>INotification</c> is broadcast. The Observer then
    ///         acts as a proxy for notifying the interested object.
    ///     </para>
    ///     <para>
    ///         Observers can receive <c>Notification</c>s by having their
    ///         <c>notifyObserver</c> method invoked, passing
    ///         in an object implementing the <c>INotification</c> interface, such
    ///         as a subclass of <c>Notification</c>.
    ///     </para>
    /// </remarks>
    /// <seealso cref="IView"/>
    /// <seealso cref="INotification"/>
    public interface IObserver
    {
        /// <summary>
        /// Set the notification method (callback) method of the interested object
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         The notification method should take one parameter of type <c>INotification</c>
        ///     </para>
        /// </remarks>
        Action<INotification> NotifyMethod { set; }

        /// <summary>
        /// Set the notification context (this) of the interested object
        /// </summary>
        object NotifyContext { set; }

        /// <summary>
        /// Notify the interested object.
        /// </summary>
        /// <param name="notification">the <c>INotification</c> to pass to the interested object's notification method</param>
        void NotifyObserver(INotification notification);

        /// <summary>
        /// Compare the given object to the notificaiton context object.
        /// </summary>
        /// <param name="obj">the object to compare.</param>
        /// <returns>indicating if the notification context and the object are the same.</returns>
        bool CompareNotifyContext(object obj);
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

namespace PureMVC.Interfaces
{
    /// <summary>
    /// The interface definition for a PureMVC Proxy.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         In PureMVC, <c>IProxy</c> implementors assume these responsibilities:
    ///         <list type="bullet">
    ///             <item>Implement a common method which returns the name of the Proxy.</item>
    ///             <item>Provide methods for setting and getting the data object.</item>
    ///         </list>
    ///     </para>
    ///     <para>
    ///         Additionally, <c>IProxy</c>s typically:
    ///         <list type="bullet">
    ///             <item>Maintain references to one or more pieces of model data.</item>
    ///             <item>Provide methods for manipulating that data.</item>
    ///             <item>Generate <c>INotifications</c> when their model data changes.</item>
    ///             <item>Expose their name as a <c>public static const</c> called <c>NAME</c>, if they are not instantiated multiple times.</item>
    ///             <item>Encapsulate interaction with local or remote services used to fetch and persist model data.</item>
    ///         </list>
    ///     </para>
    /// </remarks>
    public interface IProxy: INotifier
    {
        /// <summary>
        /// Get the Proxy name
        /// </summary>
        string ProxyName { get; }

        /// <summary>
        /// Get or Set the data object
        /// </summary>
        object Data { get; set; }

        /// <summary>
        /// Called by the Model when the Proxy is registered
        /// </summary>
        void OnRegister();

        /// <summary>
        /// Called by the Model when the Proxy is removed
        /// </summary>
        void OnRemove();
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

namespace PureMVC.Interfaces
{
    /// <summary>
    /// The interface definition for a PureMVC View.
    /// </summary>
    /// <remarks>
    ///     <para>In PureMVC, the <c>View</c> class assumes these responsibilities:</para>
    ///     <list type="bullet">
    ///         <item>Maintain a cache of <c>IMediator</c> instances</item>
    ///         <item>Provide methods for registering, retrieving, and removing <c>IMediators</c></item>
    ///         <item>Managing the observer lists for each <c>INotification</c> in the application</item>
    ///         <item>Providing a method for attaching <c>IObservers</c> to an <c>INotification</c>'s observer list</item>
    ///         <item>Providing a method for broadcasting an <c>INotification</c></item>
    ///         <item>Notifying the <c>IObservers</c> of a given <c>INotification</c> when it broadcast</item>
    ///     </list>
    /// </remarks>
    /// <seealso cref="IMediator"/>
    /// <seealso cref="IObserver"/>
    /// <seealso cref="INotification"/>
    public interface IView
    {
        /// <summary>
        /// Register an <c>IObserver</c> to be notified
        /// of <c>INotifications</c> with a given name.
        /// </summary>
        /// <param name="notificationName">the name of the <c>INotifications</c> to notify this <c>IObserver</c> of</param>
        /// <param name="observer">the <c>IObserver</c> to register</param>
        void RegisterObserver(string notificationName, IObserver observer);

        /// <summary>
        /// Remove a group of observers from the observer list for a given Notification name.
        /// </summary>
        /// <param name="notificationName">which observer list to remove from </param>
        /// <param name="notifyContext">removed the observers with this object as their notifyContext</param>
        void RemoveObserver(string notificationName, object notifyContext);

        /// <summary>
        /// Notify the <c>IObservers</c> for a particular <c>INotification</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         All previously attached <c>IObservers</c> for this <c>INotification</c>'s
        ///         list are notified and are passed a reference to the <c>INotification</c> in 
        ///         the order in which they were registered.
        ///     </para>
        /// </remarks>
        /// <param name="notification">the <c>INotification</c> to notify <c>IObservers</c> of.</param>
        void NotifyObservers(INotification notification);

        /// <summary>
        /// Register an <c>IMediator</c> instance with the <c>View</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Registers the <c>IMediator</c> so that it can be retrieved by name,
        ///         and further interrogates the <c>IMediator</c> for its 
        ///         <c>INotification</c> interests.
        ///     </para>
        ///     <para>
        ///         If the <c>IMediator</c> returns any <c>INotification</c> 
        ///         names to be notified about, an <c>Observer</c> is created encapsulating 
        ///         the <c>IMediator</c> instance's <c>handleNotification</c> method 
        ///         and registering it as an <c>Observer</c> for all <c>INotifications</c> the 
        ///         <c>IMediator</c> is interested in.
        ///     </para>
        /// </remarks>
        /// <param name="mediator">a reference to the <c>IMediator</c> instance</param>
        void RegisterMediator(IMediator mediator);

        /// <summary>
        /// Retrieve an <c>IMediator</c> from the <c>View</c>.
        /// </summary>
        /// <param name="mediatorName">the name of the <c>IMediator</c> instance to retrieve.</param>
        /// <returns>the <c>IMediator</c> instance previously registered with the given <c>mediatorName</c>.</returns>
        IMediator RetrieveMediator(string mediatorName);

        /// <summary>
        /// Remove an <c>IMediator</c> from the <c>View</c>.
        /// </summary>
        /// <param name="mediatorName">name of the <c>IMediator</c> instance to be removed.</param>
        /// <returns>the <c>IMediator</c> that was removed from the <c>View</c></returns>
        IMediator RemoveMediator(string mediatorName);

        /// <summary>
        /// Check if a Mediator is registered or not
        /// </summary>
        /// <param name="mediatorName"></param>
        /// <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        bool HasMediator(string mediatorName);
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using System;
using System.Collections.Generic;
using PureMVC.Interfaces;
using PureMVC.Patterns.Observer;

namespace PureMVC.Patterns.Command
{
    /// <summary>
    /// A base <c>ICommand</c> implementation that executes other <c>ICommand</c>s.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         A <c>MacroCommand</c> maintains an list of
    ///         <c>ICommand</c> Class references called <i>SubCommands</i>.
    ///     </para>
    ///     <para>
    ///         When <c>execute</c> is called, the <c>MacroCommand</c> 
    ///         instantiates and calls <c>execute</c> on each of its <i>SubCommands</i> turn.
    ///         Each <i>SubCommand</i> will be passed a reference to the original
    ///         <c>INotification</c> that was passed to the <c>MacroCommand</c>'s 
    ///         <c>execute</c> method.
    ///     </para>
    ///     <para>
    ///         Unlike <c>SimpleCommand</c>, your subclass
    ///         should not override <c>execute</c>, but instead, should 
    ///         override the <c>initializeMacroCommand</c> method, 
    ///         calling <c>addSubCommand</c> once for each <i>SubCommand</i>
    ///         to be executed.
    ///     </para>
    /// </remarks>
    /// <seealso cref="PureMVC.Core.Controller"/>
    /// <seealso cref="PureMVC.Patterns.Observer.Notification"/>
    /// <seealso cref="PureMVC.Patterns.Command.SimpleCommand"/>
    public class MacroCommand : Notifier, ICommand, INotifier
    {
        /// <summary>
        /// Constructor.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         You should not need to define a constructor, 
        ///         instead, override the <c>initializeMacroCommand</c>
        ///         method.
        ///     </para>
        ///     <para>
        ///         If your subclass does define a constructor, be 
        ///         sure to call <c>super()</c>.
        ///     </para>
        /// </remarks>
        public MacroCommand()
        {
            subcommands = new List<Func<ICommand>>();
            InitializeMacroCommand();
        }

        /// <summary>
        /// Initialize the <c>MacroCommand</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         In your subclass, override this method to 
        ///         initialize the <c>MacroCommand</c>'s <i>SubCommand</i>  
        ///         list with <c>ICommand</c> class references like
        ///         this:
        ///     </para>
        ///     <example>
        ///         <code>
        ///             override void InitializeMacroCommand() 
        ///             {
        ///                 AddSubCommand(() => new com.me.myapp.controller.FirstCommand());
        ///                 AddSubCommand(() => new com.me.myapp.controller.SecondCommand());
        ///                 AddSubCommand(() => new com.me.myapp.controller.ThirdCommand());
        ///             }
        ///         </code>
        ///     </example>
        ///     <para>
        ///         Note that <i>SubCommand</i>s may be any <c>ICommand</c> implementor,
        ///         <c>MacroCommand</c>s or <c>SimpleCommands</c> are both acceptable.
        ///     </para>
        /// </remarks>
        protected virtual void InitializeMacroCommand()
        {
        }

        /// <summary>
        /// Add a <c>SubCommand</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         The <i>SubCommands</i> will be called in First In/First Out (FIFO)
        ///         order.
        ///     </para>
        /// </remarks>
        /// <param name="commandClassRef">a reference to the <c>FuncDelegate</c> of the <c>ICommand</c>.</param>
        protected void AddSubCommand(Func<ICommand> commandClassRef)
        {
            subcommands.Add(commandClassRef);
        }

        /// <summary>
        /// Execute this <c>MacroCommand</c>'s <i>SubCommands</i>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         The <i>SubCommands</i> will be called in First In/First Out (FIFO)
        ///         order.
        ///     </para>
        /// </remarks>
        /// <param name="notification">the <c>INotification</c> object to be passsed to each <i>SubCommand</i>.</param>
        public virtual void Execute(INotification notification)
        {
            while(subcommands.Count > 0)
            {
                Func<ICommand> commandClassRef = subcommands[0];
                ICommand commandInstance = commandClassRef();
                commandInstance.InitializeNotifier(MultitonKey);
                commandInstance.Execute(notification);
                subcommands.RemoveAt(0);
            }
        }

        /// <summary>List of subcommands</summary>
        public IList<Func<ICommand>> subcommands;
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using PureMVC.Interfaces;
using PureMVC.Patterns.Observer;

namespace PureMVC.Patterns.Command
{
    /// <summary>
    /// A base <c>ICommand</c> implementation.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         Your subclass should override the <c>execute</c> 
    ///         method where your business logic will handle the <c>INotification</c>. 
    ///     </para>
    /// </remarks>
    /// <seealso cref="PureMVC.Core.Controller"/>
    /// <seealso cref="PureMVC.Patterns.Observer.Notification"/>
    /// <seealso cref="PureMVC.Patterns.Command.MacroCommand"/>
    public class SimpleCommand : Notifier, ICommand, INotifier
    {
        /// <summary>
        /// Fulfill the use-case initiated by the given <c>INotification</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         In the Command Pattern, an application use-case typically
        ///         begins with some user action, which results in an <c>INotification</c> being broadcast, which 
        ///         is handled by business logic in the <c>execute</c> method of an
        ///         <c>ICommand</c>.
        ///     </para>
        /// </remarks>
        /// <param name="notification">the <c>INotification</c> to handle.</param>
        public virtual void Execute(INotification notification)
        {
        }
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using System;
using PureMVC.Interfaces;
using PureMVC.Core;
using PureMVC.Patterns.Observer;
using System.Collections.Concurrent;

namespace PureMVC.Patterns.Facade
{
    /// <summary>
    /// A base Multiton <c>IFacade</c> implementation.
    /// </summary>
    /// <seealso cref="PureMVC.Core.Model"/>
    /// <seealso cref="PureMVC.Core.View"/>
    /// <seealso cref="PureMVC.Core.Controller"/>
    public class Facade: IFacade
    {
        /// <summary>
        /// Constructor.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         This <c>IFacade</c> implementation is a Multiton, 
        ///         so you should not call the constructor 
        ///         directly, but instead call the static Factory method, 
        ///         passing the unique key for this instance 
        ///         <c>Facade.getInstance( multitonKey, () => new Facade(multitonKey) )</c>
        ///     </para>
        /// </remarks>
        /// <param name="key">Key of view</param>
        /// <exception cref="System.Exception">Thrown if instance for this Multiton key has already been constructed</exception>
        public Facade(string key)
        {
            if (instanceMap.TryGetValue(key, out Lazy<IFacade> facade) && multitonKey != null) throw new Exception(MULTITON_MSG);
            InitializeNotifier(key);
            instanceMap.TryAdd(key, new Lazy<IFacade>(() => this));
            InitializeFacade();
        }

        /// <summary>
        /// Initialize the Multiton <c>Facade</c> instance.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Called automatically by the constructor. Override in your
        ///         subclass to do any subclass specific initializations. Be
        ///         sure to call <c>super.initializeFacade()</c>, though.
        ///     </para>
        /// </remarks>
        protected virtual void InitializeFacade()
        {
            InitializeModel();
            InitializeController();
            InitializeView();
        }

        /// <summary>
        /// Facade Multiton Factory method
        /// </summary>
        /// <param name="key">Key of facade</param>
        /// <param name="facadeClassRef">the <c>FuncDelegate</c> of the <c>IFacade</c></param>
        /// <returns>the Multiton instance of the Facade</returns>
        public static IFacade GetInstance(string key, Func<IFacade> facadeClassRef)
        {
            return instanceMap.GetOrAdd(key, new Lazy<IFacade>(facadeClassRef)).Value;
        }

        /// <summary>
        /// Initialize the <c>Controller</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Called by the <c>initializeFacade</c> method.
        ///         Override this method in your subclass of <c>Facade</c> 
        ///         if one or both of the following are true:
        ///         <list type="bullet">
        ///             <item>You wish to initialize a different <c>IController</c>.</item>
        ///             <item>You have <c>Commands</c> to register with the <c>Controller</c> at startup.</item>
        ///         </list>
        ///     </para>
        ///     <para>
        ///         If you don't want to initialize a different <c>IController</c>, 
        ///         call <c>super.initializeController()</c> at the beginning of your
        ///         method, then register <c>Command</c>s.
        ///     </para>
        /// </remarks>
        protected virtual void InitializeController()
        {
            controller = Controller.GetInstance(multitonKey, () => new Controller(multitonKey));
        }

        /// <summary>
        /// Initialize the <c>Model</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Called by the <c>initializeFacade</c> method.
        ///         Override this method in your subclass of <c>Facade</c> 
        ///         if one or both of the following are true:
        ///         <list type="bullet">
        ///             <item>You wish to initialize a different <c>IModel</c>.</item>
        ///             <item>You have <c>Proxy</c>s to register with the <c>Model</c> that do not
        ///                 retrieve a reference to the Facade at construction time.
        ///             </item>
        ///         </list>
        ///     </para>
        ///     <para>
        ///         If you don't want to initialize a different <c>IModel</c>, 
        ///         call <c>super.initializeModel()</c> at the beginning of your
        ///         method, then register <c>Proxy</c>s.
        ///     </para>
        ///     <para>
        ///         Note: This method is <i>rarely</i> overridden; in practice you are more
        ///         likely to use a <c>Command</c> to create and register <c>Proxy</c>s
        ///         with the <c>Model</c>, since <c>Proxy</c>s with mutable data will likely
        ///         need to send <c>INotification</c>s and thus will likely want to fetch a reference to 
        ///         the <c>Facade</c> during their construction. 
        ///     </para>
        /// </remarks>
        protected virtual void InitializeModel()
        {
            model = Model.GetInstance(multitonKey, () => new Model(multitonKey));
        }

        /// <summary>
        /// Initialize the <c>View</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Called by the <c>initializeFacade</c> method.
        ///         Override this method in your subclass of <c>Facade</c> 
        ///         if one or both of the following are true:
        ///         <list type="bullet">
        ///             <item>You wish to initialize a different <c>IView</c>.</item>
        ///             <item>You have <c>Observers</c> to register with the <c>View</c></item>
        ///         </list>
        ///     </para>
        /// </remarks>
        protected virtual void InitializeView()
        {
            view = View.GetInstance(multitonKey, () => new View(multitonKey));
        }

        /// <summary>
        /// Register an <c>ICommand</c> with the <c>Controller</c> by Notification name.
        /// </summary>
        /// <param name="notificationName">the name of the <c>INotification</c> to associate the <c>ICommand</c> with</param>
        /// <param name="commandClassRef">a reference to the Class of the <c>ICommand</c></param>
        public virtual void RegisterCommand(string notificationName, Func<ICommand> commandClassRef)
        {
            controller.RegisterCommand(notificationName, commandClassRef);
        }

        /// <summary>
        /// Remove a previously registered <c>ICommand</c> to <c>INotification</c> mapping from the Controller.
        /// </summary>
        /// <param name="notificationName">the name of the <c>INotification</c> to remove the <c>ICommand</c> mapping for</param>
        public virtual void RemoveCommand(string notificationName)
        {
            controller.RemoveCommand(notificationName);
        }

        /// <summary>
        /// Check if a Command is registered for a given Notification 
        /// </summary>
        /// <param name="notificationName"></param>
        /// <returns>whether a Command is currently registered for the given <c>notificationName</c>.</returns>
        public virtual bool HasCommand(string notificationName)
        {
            return controller.HasCommand(notificationName);
        }

        /// <summary>
        /// Register an <c>IProxy</c> with the <c>Model</c> by name.
        /// </summary>
        /// <param name="proxy">the <c>IProxy</c> instance to be registered with the <c>Model</c>.</param>
        public virtual void RegisterProxy(IProxy proxy)
        {
            model.RegisterProxy(proxy);
        }

        /// <summary>
        /// Retrieve an <c>IProxy</c> from the <c>Model</c> by name.
        /// </summary>
        /// <param name="proxyName">the name of the proxy to be retrieved.</param>
        /// <returns>the <c>IProxy</c> instance previously registered with the given <c>proxyName</c>.</returns>
        public virtual IProxy RetrieveProxy(string proxyName)
        {
            return model.RetrieveProxy(proxyName);
        }

        /// <summary>
        /// Remove an <c>IProxy</c> from the <c>Model</c> by name.
        /// </summary>
        /// <param name="proxyName">the <c>IProxy</c> to remove from the <c>Model</c>.</param>
        /// <returns>the <c>IProxy</c> that was removed from the <c>Model</c></returns>
        public virtual IProxy RemoveProxy(string proxyName)
        {
            return model.RemoveProxy(proxyName);
        }

        /// <summary>
        /// Check if a Proxy is registered
        /// </summary>
        /// <param name="proxyName"></param>
        /// <returns>whether a Proxy is currently registered with the given <c>proxyName</c>.</returns>
        public virtual bool HasProxy(string proxyName)
        {
            return model.HasProxy(proxyName);
        }

        /// <summary>
        /// Register a <c>IMediator</c> with the <c>View</c>.
        /// </summary>
        /// <param name="mediator">a reference to the <c>IMediator</c></param>
        public virtual void RegisterMediator(IMediator mediator)
        {
            view.RegisterMediator(mediator);
        }

        /// <summary>
        /// Retrieve an <c>IMediator</c> from the <c>View</c>.
        /// </summary>
        /// <param name="mediatorName"></param>
        /// <returns>the <c>IMediator</c> previously registered with the given <c>mediatorName</c>.</returns>
        public virtual IMediator RetrieveMediator(string mediatorName)
        {
            return view.RetrieveMediator(mediatorName);
        }

        /// <summary>
        /// Remove an <c>IMediator</c> from the <c>View</c>.
        /// </summary>
        /// <param name="mediatorName">name of the <c>IMediator</c> to be removed.</param>
        /// <returns>the <c>IMediator</c> that was removed from the <c>View</c></returns>
        public virtual IMediator RemoveMediator(string mediatorName)
        {
            return view.RemoveMediator(mediatorName);
        }

        /// <summary>
        /// Check if a Mediator is registered or not
        /// </summary>
        /// <param name="mediatorName"></param>
        /// <returns>whether a Mediator is registered with the given <c>mediatorName</c>.</returns>
        public virtual bool HasMediator(string mediatorName)
        {
            return view.HasMediator(mediatorName);
        }

        /// <summary>
        /// Create and send an <c>INotification</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Keeps us from having to construct new notification 
        ///         instances in our implementation code.
        ///     </para>
        /// </remarks>
        /// <param name="notificationName">the name of the notiification to send</param>
        /// <param name="body">the body of the notification (optional)</param>
        /// <param name="type">type the type of the notification (optional)</param>
        public virtual void SendNotification(string notificationName, object body=null, string type = null)
        {
            NotifyObservers(new Notification(notificationName, body, type));
        }

        /// <summary>
        /// Notify <c>Observer</c>s.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         This method is left public mostly for backward 
        ///         compatibility, and to allow you to send custom 
        ///         notification classes using the facade.
        ///     </para>
        ///     <para>
        ///         Usually you should just call sendNotification
        ///         and pass the parameters, never having to 
        ///         construct the notification yourself.
        ///     </para>
        /// </remarks>
        /// <param name="notification">the <c>INotification</c> to have the <c>View</c> notify <c>Observers</c> of.</param>
        public virtual void NotifyObservers(INotification notification)
        {
            view.NotifyObservers(notification);
        }

        /// <summary>
        /// Set the Multiton key for this facade instance.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Not called directly, but instead from the 
        ///         constructor when getInstance is invoked.
        ///         It is necessary to be public in order to 
        ///         implement INotifier.
        ///     </para>
        /// </remarks>
        /// <param name="key"></param>
        public virtual void InitializeNotifier(string key)
        {
            multitonKey = key;
        }

        /// <summary>
        ///  Check if a Core is registered or not
        /// </summary>
        /// <param name="key">the multiton key for the Core in question</param>
        /// <returns>whether a Core is registered with the given <c>key</c>.</returns>
        public static bool HasCore(string key)
        {
            return instanceMap.TryGetValue(key, out Lazy<IFacade> _);
        }

        /// <summary>
        /// Remove a Core.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Remove the Model, View, Controller and Facade 
        ///         instances for the given key.
        ///     </para>
        /// </remarks>
        /// <param name="key">multitonKey of the Core to remove</param>
        public static void RemoveCore(string key)
        {
            if (instanceMap.TryGetValue(key, out Lazy<IFacade> _) == false) return;
            Model.RemoveModel(key);
            View.RemoveView(key);
            Controller.RemoveController(key);
            instanceMap.TryRemove(key, out Lazy<IFacade> _);
        }

        /// <summary>References to Controller</summary>
        protected IController controller;

        /// <summary>References to Model</summary>
        protected IModel model;

        /// <summary>References to View</summary>
        protected IView view;

        /// <summary>The Multiton Key for this app</summary>
        protected string multitonKey;

        /// <summary>The Multiton Facade instanceMap.</summary>
        protected static ConcurrentDictionary<string, Lazy<IFacade>> instanceMap = new ConcurrentDictionary<string, Lazy<IFacade>>();

        /// <summary>Message Constants</summary>
        protected const string MULTITON_MSG = "View instance for this Multiton key already constructed!";
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using PureMVC.Interfaces;
using PureMVC.Patterns.Observer;

namespace PureMVC.Patterns.Mediator
{
    /// <summary>
    /// A base <c>IMediator</c> implementation. 
    /// </summary>
    /// <seealso cref="PureMVC.Core.View"/>
    public class Mediator : Notifier, IMediator, INotifier
    {
        /// <summary>
        /// The name of the <c>Mediator</c>. 
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Typically, a <c>Mediator</c> will be written to serve
        ///         one specific control or group controls and so,
        ///         will not have a need to be dynamically named.
        ///     </para>
        /// </remarks>
        public static string NAME = "Mediator";

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="mediatorName"></param>
        /// <param name="viewComponent"></param>
        public Mediator(string mediatorName, object viewComponent = null)
        {
            MediatorName = mediatorName ?? Mediator.NAME;
            ViewComponent = viewComponent;
        }

        /// <summary>
        /// List the <c>INotification</c> names this
        /// <c>Mediator</c> is interested in being notified of.
        /// </summary>
        /// <returns>the list of <c>INotification</c> names</returns>
        public virtual string[] ListNotificationInterests()
        {
            return new string[0];
        }

        /// <summary>
        /// Handle <c>INotification</c>s.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Typically this will be handled in a switch statement,
        ///         with one 'case' entry per <c>INotification</c>
        ///         the <c>Mediator</c> is interested in.
        ///     </para>
        /// </remarks>
        /// <param name="notification"></param>
        public virtual void HandleNotification(INotification notification)
        {
        }

        /// <summary>
        /// Called by the View when the Mediator is registered
        /// </summary>
        public virtual void OnRegister()
        {
        }

        /// <summary>
        /// Called by the View when the Mediator is removed
        /// </summary>
        public virtual void OnRemove()
        {
        }

        /// <summary>the mediator name</summary>
        public string MediatorName { get; protected set; }

        /// <summary>The view component</summary>
        public object ViewComponent { get; set; }
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using PureMVC.Interfaces;

namespace PureMVC.Patterns.Observer
{
    /// <summary>
    /// A base <c>INotification</c> implementation.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         PureMVC does not rely upon underlying event models such 
    ///         as the one provided with Flash, and ActionScript 3 does 
    ///         not have an inherent event model.
    ///     </para>
    ///     <para>
    ///         The Observer Pattern as implemented within PureMVC exists 
    ///         to support event-driven communication between the 
    ///         application and the actors of the MVC triad.
    ///     </para>
    ///     <para>
    ///         Notifications are not meant to be a replacement for Events
    ///         in Flex/Flash/Apollo. Generally, <c>IMediator</c> implementors
    ///         place event listeners on their view components, which they
    ///         then handle in the usual way. This may lead to the broadcast of <c>Notification</c>s to 
    ///         trigger <c>ICommand</c>s or to communicate with other <c>IMediators</c>. 
    ///         <c>IProxy</c> and <c>ICommand</c>
    ///         instances communicate with each other and <c>IMediator</c>s
    ///         by broadcasting <c>INotification</c>s.
    ///     </para>
    ///     <para>
    ///         A key difference between Flash <c>Event</c>s and PureMVC
    ///         <c>Notification</c>s is that <c>Event</c>s follow the 
    ///         'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy 
    ///         until some parent component handles the <c>Event</c>, while
    ///         PureMVC <c>Notification</c>s follow a 'Publish/Subscribe'
    ///         pattern. PureMVC classes need not be related to each other in a 
    ///         parent/child relationship in order to communicate with one another
    ///         using <c>Notification</c>s.
    ///     </para>
    /// </remarks>
    /// <seealso cref="PureMVC.Patterns.Observer.Observer"/>
    public class Notification: INotification
    {
        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="name">name of the <c>Notification</c> instance. (required)</param>
        /// <param name="body">the <c>Notification</c> body. (optional)</param>
        /// <param name="type">the type of the <c>Notification</c> (optional)</param>
        public Notification(string name, object body=null, string type=null)
        {
            Name = name;
            Body = body;
            Type = type;
        }

        /// <summary>
        /// Get the string representation of the <c>Notification</c> instance.
        /// </summary>
        /// <returns>the string representation of the <c>Notification</c> instance.</returns>
        public override string ToString()
        {
            string msg = "Notification Name: " + Name;
            msg += "\nBody:" + ((Body == null) ? "null" : Body.ToString());
            msg += "\nType:" + ((Type == null) ? "null" : Type);
            return msg;
        }

        /// <summary>the name of the notification instance</summary>
        public string Name { get; }

        /// <summary>the body of the notification instance</summary>
        public object Body { get; set; }

        /// <summary>the type of the notification instance</summary>
        public string Type { get; set; }
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using System;
using PureMVC.Interfaces;

namespace PureMVC.Patterns.Observer
{
    /// <summary>
    /// A Base <c>INotifier</c> implementation.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         <c>MacroCommand, Command, Mediator</c> and <c>Proxy</c> 
    ///         all have a need to send <c>Notifications</c>.
    ///     </para>
    ///     <para>
    ///         The <c>INotifier</c> interface provides a common method called
    ///         <c>sendNotification</c> that relieves implementation code of 
    ///         the necessity to actually construct <c>Notifications</c>.
    ///     </para>
    ///     <para>
    ///         The <c>Notifier</c> class, which all of the above mentioned classes
    ///         extend, provides an initialized reference to the <c>Facade</c>
    ///         Multiton, which is required for the convienience method
    ///         for sending <c>Notifications</c>, but also eases implementation as these
    ///         classes have frequent <c>Facade</c> interactions and usually require
    ///         access to the facade anyway.
    ///     </para>
    ///     <para>
    ///         NOTE: In the MultiCore version of the framework, there is one caveat to
    ///         notifiers, they cannot send notifications or reach the facade until they
    ///         have a valid multitonKey.
    ///         The multitonKey is set:
    ///         <list type="bullet">
    ///             <item>on a Command when it is executed by the Controller</item>
    ///             <item>on a Mediator is registered with the View</item>
    ///             <item>on a Proxy is registered with the Model.</item>
    ///         </list>
    ///     </para>
    /// </remarks>
    /// <seealso cref="PureMVC.Patterns.Proxy.Proxy"/>
    /// <seealso cref="PureMVC.Patterns.Facade.Facade"/>
    /// <seealso cref="PureMVC.Patterns.Mediator.Mediator"/>
    /// <seealso cref="PureMVC.Patterns.Command.MacroCommand"/>
    /// <seealso cref="PureMVC.Patterns.Command.SimpleCommand"/>
    public class Notifier: INotifier
    {
        /// <summary>
        /// Create and send an <c>INotification</c>.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         Keeps us from having to construct new INotification 
        ///         instances in our implementation code.
        ///     </para>
        /// </remarks>
        /// <param name="notificationName">the name of the notiification to send</param>
        /// <param name="body">the body of the notification (optional)</param>
        /// <param name="type">the type of the notification (optional)</param>
        public virtual void SendNotification(string notificationName, object body = null, string type = null)
        {
            Facade.SendNotification(notificationName, body, type);
        }

        /// <summary>
        /// Initialize this INotifier instance.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         This is how a Notifier gets its multitonKey. 
        ///         Calls to sendNotification or to access the
        ///         facade will fail until after this method 
        ///         has been called.
        ///     </para>
        ///     <para>
        ///         Mediators, Commands or Proxies may override 
        ///         this method in order to send notifications
        ///         or access the Multiton Facade instance as
        ///         soon as possible. They CANNOT access the facade
        ///         in their constructors, since this method will not
        ///         yet have been called.
        ///     </para>
        /// </remarks>
        /// <param name="key">the multitonKey for this INotifier to use</param>
        public void InitializeNotifier(string key)
        {
            MultitonKey = key;
        }

        /// <summary> Return the Multiton Facade instance</summary>
        protected IFacade Facade
        {
            get {
                if (MultitonKey == null) throw new Exception(MULTITON_MSG);
                return Patterns.Facade.Facade.GetInstance(MultitonKey, () => new Facade.Facade(MultitonKey));
            }
        }

        /// <summary>The Multiton Key for this app</summary>
        public string MultitonKey { get; protected set; }

        /// <summary>Message Constants</summary>
        protected string MULTITON_MSG = "multitonKey for this Notifier not yet initialized!";
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using System;
using PureMVC.Interfaces;

namespace PureMVC.Patterns.Observer
{
    /// <summary>
    /// A base <c>IObserver</c> implementation.
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         An <c>Observer</c> is an object that encapsulates information
    ///         about an interested object with a method that should 
    ///         be called when a particular <c>INotification</c> is broadcast. 
    ///     </para>
    ///     <para>
    ///         In PureMVC, the <c>Observer</c> class assumes these responsibilities:
    ///         <list type="bullet">
    ///             <item>Encapsulate the notification (callback) method of the interested object.</item>
    ///             <item>Encapsulate the notification context (this) of the interested object.</item>
    ///             <item>Provide methods for setting the notification method and context.</item>
    ///             <item>Provide a method for notifying the interested object.</item>
    ///         </list>
    ///     </para>
    /// </remarks>
    /// <seealso cref="PureMVC.Core.View"/>
    /// <seealso cref="PureMVC.Patterns.Observer.Notification"/>
    public class Observer: IObserver
    {
        /// <summary>
        /// Constructor.
        /// </summary>
        /// <remarks>
        ///     <para>
        ///         The notification method on the interested object should take 
        ///         one parameter of type <c>INotification</c>
        ///     </para>
        /// </remarks>
        /// <param name="notifyMethod">the notification method of the interested object</param>
        /// <param name="notifyContext">the notification context of the interested object</param>
        public Observer(Action<INotification> notifyMethod, object notifyContext)
        {
            NotifyMethod = notifyMethod;
            NotifyContext = notifyContext;
        }

        /// <summary>
        /// Notify the interested object.
        /// </summary>
        /// <param name="Notification">the <c>INotification</c> to pass to the interested object's notification method.</param>
        public virtual void NotifyObserver(INotification Notification)
        {
            NotifyMethod(Notification);
        }

        /// <summary>
        /// Compare an object to the notification context. 
        /// </summary>
        /// <param name="obj">the object to compare</param>
        /// <returns>indicating if the object and the notification context are the same</returns>
        public virtual bool CompareNotifyContext(object obj)
        {
            return NotifyContext.Equals(obj);
        }

        /// <summary>Callback method</summary>
        public Action<INotification> NotifyMethod { get; set; }

        /// <summary>Context object</summary>
        public object NotifyContext { get; set; }
    }
}
﻿//
//  PureMVC C# Multicore
//
//  Copyright(c) 2017 Saad Shams <saad.shams@puremvc.org>
//  Your reuse is governed by the Creative Commons Attribution 3.0 License
//

using PureMVC.Interfaces;
using PureMVC.Patterns.Observer;

namespace PureMVC.Patterns.Proxy
{
    /// <summary>
    /// A base <c>IProxy</c> implementation. 
    /// </summary>
    /// <remarks>
    ///     <para>
    ///         In PureMVC, <c>Proxy</c> classes are used to manage parts of the 
    ///         application's data model.
    ///     </para>
    ///     <para>
    ///          A <c>Proxy</c> might simply manage a reference to a local data object, 
    ///          in which case interacting with it might involve setting and 
    ///          getting of its data in synchronous fashion.
    ///     </para>
    ///     <para>
    ///         <c>Proxy</c> classes are also used to encapsulate the application's 
    ///         interaction with remote services to save or retrieve data, in which case,
    ///         we adopt an asyncronous idiom; setting data (or calling a method) on the 
    ///         <c>Proxy</c> and listening for a <c>Notification</c> to be sent 
    ///         when the <c>Proxy</c> has retrieved the data from the service.
    ///     </para>
    /// </remarks>
    /// <seealso cref="PureMVC.Core.Model"/>
    public class Proxy: Notifier, IProxy, INotifier
    {
        /// <summary>Name of the proxy</summary>
        public static string NAME = "Proxy";

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="proxyName"></param>
        /// <param name="data"></param>
        public Proxy(string proxyName, object data=null)
        {
            ProxyName = proxyName ?? Proxy.NAME;
            if (data != null) Data = data;
        }

        /// <summary>
        /// Called by the Model when the Proxy is registered
        /// </summary>
        public virtual void OnRegister()
        { 
        }

        /// <summary>
        /// Called by the Model when the Proxy is removed
        /// </summary>
        public virtual void OnRemove()
        {
        }

        /// <summary>the proxy name</summary>
        public string ProxyName { get; protected set; }

        /// <summary>the proxy name</summary>
        public object Data { get; set; }
    }
}
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ExamplesPureMVCLuaFrameworkTest : MonoBehaviour
{
    void Start()
    {
        
    }


    void Update()
    {
        
    }
}
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 0
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 10304, guid: 0000000000000000f000000000000000, type: 0}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 0}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 11
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 1
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 1
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 512
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 256
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 1
    m_PVRDenoiserTypeDirect: 1
    m_PVRDenoiserTypeIndirect: 1
    m_PVRDenoiserTypeAO: 1
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 1
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_UseShadowmask: 1
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1 &1392130433
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1392130436}
  - component: {fileID: 1392130435}
  - component: {fileID: 1392130434}
  - component: {fileID: 1392130437}
  m_Layer: 0
  m_Name: Main Camera
  m_TagString: MainCamera
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!81 &1392130434
AudioListener:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1392130433}
  m_Enabled: 1
--- !u!20 &1392130435
Camera:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1392130433}
  m_Enabled: 1
  serializedVersion: 2
  m_ClearFlags: 1
  m_BackGroundColor: {r: 0.19215687, g: 0.3019608, b: 0.4745098, a: 0}
  m_projectionMatrixMode: 1
  m_GateFitMode: 2
  m_FOVAxisMode: 0
  m_SensorSize: {x: 36, y: 24}
  m_LensShift: {x: 0, y: 0}
  m_FocalLength: 50
  m_NormalizedViewPortRect:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  near clip plane: 0.3
  far clip plane: 1000
  field of view: 60
  orthographic: 0
  orthographic size: 5
  m_Depth: -1
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingPath: -1
  m_TargetTexture: {fileID: 0}
  m_TargetDisplay: 0
  m_TargetEye: 3
  m_HDR: 1
  m_AllowMSAA: 1
  m_AllowDynamicResolution: 0
  m_ForceIntoRT: 0
  m_OcclusionCulling: 1
  m_StereoConvergence: 10
  m_StereoSeparation: 0.022
--- !u!4 &1392130436
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1392130433}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 1, z: -10}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!114 &1392130437
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1392130433}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 38947df5406889044a18b08e81078301, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
--- !u!1 &1514535145
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1514535147}
  - component: {fileID: 1514535146}
  m_Layer: 0
  m_Name: Directional Light
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!108 &1514535146
Light:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1514535145}
  m_Enabled: 1
  serializedVersion: 10
  m_Type: 1
  m_Shape: 0
  m_Color: {r: 1, g: 0.95686275, b: 0.8392157, a: 1}
  m_Intensity: 1
  m_Range: 10
  m_SpotAngle: 30
  m_InnerSpotAngle: 21.80208
  m_CookieSize: 10
  m_Shadows:
    m_Type: 2
    m_Resolution: -1
    m_CustomResolution: -1
    m_Strength: 1
    m_Bias: 0.05
    m_NormalBias: 0.4
    m_NearPlane: 0.2
    m_CullingMatrixOverride:
      e00: 1
      e01: 0
      e02: 0
      e03: 0
      e10: 0
      e11: 1
      e12: 0
      e13: 0
      e20: 0
      e21: 0
      e22: 1
      e23: 0
      e30: 0
      e31: 0
      e32: 0
      e33: 1
    m_UseCullingMatrixOverride: 0
  m_Cookie: {fileID: 0}
  m_DrawHalo: 0
  m_Flare: {fileID: 0}
  m_RenderMode: 0
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingLayerMask: 1
  m_Lightmapping: 4
  m_LightShadowCasterMode: 0
  m_AreaSize: {x: 1, y: 1}
  m_BounceIntensity: 1
  m_ColorTemperature: 6570
  m_UseColorTemperature: 0
  m_BoundingSphereOverride: {x: 0, y: 0, z: 0, w: 0}
  m_UseBoundingSphereOverride: 0
  m_ShadowRadius: 0
  m_ShadowAngle: 0
--- !u!4 &1514535147
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1514535145}
  m_LocalRotation: {x: 0.40821788, y: -0.23456968, z: 0.10938163, w: 0.8754261}
  m_LocalPosition: {x: 0, y: 3, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 50, y: -30, z: 0}
﻿using PureMVC.Interfaces;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class StartUPCommand : PureMVC.Patterns.Command.SimpleCommand
{
    public override void Execute(INotification notification)
    {
        var testpanel = Resources.Load<GameObject>("testPanel");
        var tp = GameObject.Instantiate(testpanel, GameObject.Find("Canvas").transform);
        Facade.RegisterMediator(new TestPanelMediator(tp));

        Facade.RegisterMediator(new TestYesWindowMediator(Resources.Load<GameObject>("TestYesWindow")));
    }
}
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &1599905054482620077
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1599905054482620078}
  - component: {fileID: 1599905054482620073}
  - component: {fileID: 1599905054482620072}
  - component: {fileID: 1599905054482620079}
  m_Layer: 5
  m_Name: Button
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1599905054482620078
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905054482620077}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 1599905054514608274}
  m_Father: {fileID: 1599905055667502093}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 300, y: 96}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &1599905054482620073
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905054482620077}
  m_CullTransparentMesh: 0
--- !u!114 &1599905054482620072
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905054482620077}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!114 &1599905054482620079
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905054482620077}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 1599905054482620072}
  m_OnClick:
    m_PersistentCalls:
      m_Calls: []
--- !u!1 &1599905054514608273
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1599905054514608274}
  - component: {fileID: 1599905054514608268}
  - component: {fileID: 1599905054514608275}
  m_Layer: 5
  m_Name: Text
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1599905054514608274
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905054514608273}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 1599905054482620078}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &1599905054514608268
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905054514608273}
  m_CullTransparentMesh: 0
--- !u!114 &1599905054514608275
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905054514608273}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 50
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 5
    m_MaxSize: 50
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: "\u786E\u8BA4"
--- !u!1 &1599905055667502092
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 1599905055667502093}
  - component: {fileID: 1599905055667502095}
  - component: {fileID: 1599905055667502094}
  - component: {fileID: 1599905055667502088}
  m_Layer: 5
  m_Name: testPanel
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &1599905055667502093
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905055667502092}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 1599905054482620078}
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &1599905055667502095
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905055667502092}
  m_CullTransparentMesh: 0
--- !u!114 &1599905055667502094
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905055667502092}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 0.392}
  m_RaycastTarget: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10907, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!114 &1599905055667502088
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 1599905055667502092}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 426e12da086829e4a88b73d03e937a06, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  TestButton: {fileID: 1599905054482620079}
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class TestPanel : MonoBehaviour
{
    public Button TestButton;
}
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TestPanelMediator : PureMVC.Patterns.Mediator.Mediator
{
    public new const string NAME = "TestPanelMediator";
    private TestPanel View;
    public TestPanelMediator(object viewCommponent):base(NAME, viewCommponent)
    {
        View = ((GameObject)ViewComponent).GetComponent<TestPanel>();
        Debug.Log(NAME + " 对象已创建");
        View.TestButton.onClick.AddListener(OnViewTestButtonClicked);
    }

    public void OnViewTestButtonClicked()
    {
        Debug.Log("确认按钮点击了");
        SendNotification(KSwordKit.AppFacade.TestPanel_ClickedYES);
    }

    public override string[] ListNotificationInterests()
    {
        return base.ListNotificationInterests();
    }
}
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &2318336376118060634
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2318336376118060635}
  - component: {fileID: 2318336376118060645}
  - component: {fileID: 2318336376118060644}
  m_Layer: 5
  m_Name: Text
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2318336376118060635
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376118060634}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 2318336376465159726}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 1, y: 1}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &2318336376118060645
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376118060634}
  m_CullTransparentMesh: 0
--- !u!114 &2318336376118060644
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376118060634}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 35
    m_FontStyle: 0
    m_BestFit: 0
    m_MinSize: 0
    m_MaxSize: 40
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: "\u5173\u95ED"
--- !u!1 &2318336376243277720
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2318336376243277721}
  - component: {fileID: 2318336376243277723}
  - component: {fileID: 2318336376243277722}
  m_Layer: 5
  m_Name: Text
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2318336376243277721
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376243277720}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 2318336376966486829}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0.5}
  m_AnchorMax: {x: 1, y: 0.5}
  m_AnchoredPosition: {x: 0, y: 83}
  m_SizeDelta: {x: 0, y: 90}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &2318336376243277723
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376243277720}
  m_CullTransparentMesh: 0
--- !u!114 &2318336376243277722
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376243277720}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 5f7201a12d95ffc409449d95f23cf332, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 0.19607843, g: 0.19607843, b: 0.19607843, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_FontData:
    m_Font: {fileID: 10102, guid: 0000000000000000e000000000000000, type: 0}
    m_FontSize: 50
    m_FontStyle: 1
    m_BestFit: 0
    m_MinSize: 5
    m_MaxSize: 50
    m_Alignment: 4
    m_AlignByGeometry: 0
    m_RichText: 1
    m_HorizontalOverflow: 0
    m_VerticalOverflow: 0
    m_LineSpacing: 1
  m_Text: "\u8FD9\u662F\u4E00\u4E2A\u7B80\u5355\u7684\u6D4B\u8BD5\u5F39\u7A97"
--- !u!1 &2318336376465159725
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2318336376465159726}
  - component: {fileID: 2318336376465159721}
  - component: {fileID: 2318336376465159720}
  - component: {fileID: 2318336376465159727}
  m_Layer: 5
  m_Name: Button
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2318336376465159726
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376465159725}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 2318336376118060635}
  m_Father: {fileID: 2318336376966486829}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: 0, y: -84}
  m_SizeDelta: {x: 300, y: 60}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &2318336376465159721
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376465159725}
  m_CullTransparentMesh: 0
--- !u!114 &2318336376465159720
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376465159725}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 1}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10905, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!114 &2318336376465159727
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376465159725}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4e29b1a8efbd4b44bb3f3716e73f07ff, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Navigation:
    m_Mode: 3
    m_SelectOnUp: {fileID: 0}
    m_SelectOnDown: {fileID: 0}
    m_SelectOnLeft: {fileID: 0}
    m_SelectOnRight: {fileID: 0}
  m_Transition: 1
  m_Colors:
    m_NormalColor: {r: 1, g: 1, b: 1, a: 1}
    m_HighlightedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_PressedColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 1}
    m_SelectedColor: {r: 0.9607843, g: 0.9607843, b: 0.9607843, a: 1}
    m_DisabledColor: {r: 0.78431374, g: 0.78431374, b: 0.78431374, a: 0.5019608}
    m_ColorMultiplier: 1
    m_FadeDuration: 0.1
  m_SpriteState:
    m_HighlightedSprite: {fileID: 0}
    m_PressedSprite: {fileID: 0}
    m_SelectedSprite: {fileID: 0}
    m_DisabledSprite: {fileID: 0}
  m_AnimationTriggers:
    m_NormalTrigger: Normal
    m_HighlightedTrigger: Highlighted
    m_PressedTrigger: Pressed
    m_SelectedTrigger: Selected
    m_DisabledTrigger: Disabled
  m_Interactable: 1
  m_TargetGraphic: {fileID: 2318336376465159720}
  m_OnClick:
    m_PersistentCalls:
      m_Calls: []
--- !u!1 &2318336376966486828
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2318336376966486829}
  - component: {fileID: 2318336376966486831}
  - component: {fileID: 2318336376966486830}
  - component: {fileID: 7651180975594740730}
  m_Layer: 5
  m_Name: TestYesWindow
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!224 &2318336376966486829
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376966486828}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children:
  - {fileID: 2318336376243277721}
  - {fileID: 2318336376465159726}
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0.5, y: 0.5}
  m_AnchorMax: {x: 0.5, y: 0.5}
  m_AnchoredPosition: {x: 0, y: -0.000015259}
  m_SizeDelta: {x: 600, y: 380.54224}
  m_Pivot: {x: 0.5, y: 0.5}
--- !u!222 &2318336376966486831
CanvasRenderer:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376966486828}
  m_CullTransparentMesh: 0
--- !u!114 &2318336376966486830
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376966486828}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: fe87c0e1cc204ed48ad3b37840f39efc, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_Material: {fileID: 0}
  m_Color: {r: 1, g: 1, b: 1, a: 0.7176471}
  m_RaycastTarget: 1
  m_Maskable: 1
  m_OnCullStateChanged:
    m_PersistentCalls:
      m_Calls: []
  m_Sprite: {fileID: 10907, guid: 0000000000000000f000000000000000, type: 0}
  m_Type: 1
  m_PreserveAspect: 0
  m_FillCenter: 1
  m_FillMethod: 4
  m_FillAmount: 1
  m_FillClockwise: 1
  m_FillOrigin: 0
  m_UseSpriteMesh: 0
  m_PixelsPerUnitMultiplier: 1
--- !u!114 &7651180975594740730
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2318336376966486828}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: b042829feb32e624cbcfeea6d5e6f6e9, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  CloseButton: {fileID: 2318336376465159727}
﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class TestYesWindow : MonoBehaviour
{
    public Button CloseButton;
}
﻿using PureMVC.Interfaces;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TestYesWindowMediator : PureMVC.Patterns.Mediator.Mediator
{
    public new const string NAME = "TestYesWindowMediator";
    GameObject prefab;
    TestYesWindow View;
    public TestYesWindowMediator(object viewCommponent):base(NAME, viewCommponent)
    {
        prefab = viewCommponent as GameObject;
        Debug.Log(NAME + " 对象已创建");
    }

    public override string[] ListNotificationInterests()
    {
        return new string[] {
            KSwordKit.AppFacade.TestPanel_ClickedYES
        };
    }
    public override void HandleNotification(INotification notification)
    {
        switch (notification.Name)
        {
            case KSwordKit.AppFacade.TestPanel_ClickedYES:
                Open();
                break;
        }
    }

    public void Open()
    {
        View = GameObject.Instantiate(prefab, GameObject.Find("Canvas").transform).GetComponent<TestYesWindow>();
        View.CloseButton.onClick.AddListener(TestYesWindowCloseButtonClicked);
        Debug.Log(View.name + " 界面已打开");

    }
    public void Close()
    {
        Debug.Log(View.name + " 界面已关闭");
        GameObject.Destroy(View.gameObject);
    }
    void TestYesWindowCloseButtonClicked()
    {
        Debug.Log("TestYesWindow关闭按钮已被点击");

        View.gameObject.SetActive(false);
        Close();
    }
}
﻿using PureMVC.Interfaces;
using PureMVC.Patterns.Facade;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class App : MonoBehaviour
{
    KSwordKit.AppFacade facade;
    void Start()
    {
        facade = Facade.GetInstance(typeof(KSwordKit.AppFacade).FullName, ()=> new KSwordKit.AppFacade(typeof(KSwordKit.AppFacade).FullName)) as KSwordKit.AppFacade;
        facade.Launch();
    }

    void Update()
    {
        
    }
}
﻿namespace KSwordKit
{
    using PureMVC.Interfaces;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;
    using UnityEngine;

    public class AppFacade : PureMVC.Patterns.Facade.Facade
    {
        public const string AppFacadeKey = "AppFacadeKey";
        public static string StartUP = "StartUP";
        public const string TestPanel_ClickedYES = "TestPanel_ClickedYES";

        public AppFacade(string key) : base(AppFacadeKey)
        {

        }

        /// <summary>
        /// 注册Command，建立Command与Notification之间的映射
        /// </summary>
        protected override void InitializeController()
        {
            base.InitializeController();
            RegisterCommand(StartUP, () => new StartUPCommand());
        }
        /// <summary>
        /// 注册Mediator
        /// </summary>
        protected override void InitializeView()
        {
            base.InitializeView();

        }
        /// <summary>
        /// 注册Proxy
        /// </summary>
        protected override void InitializeModel()
        {
            base.InitializeModel();

        }

        public void Launch()
        {
            SendNotification(StartUP);
        }
    }

}%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!29 &1
OcclusionCullingSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 2
  m_OcclusionBakeSettings:
    smallestOccluder: 5
    smallestHole: 0.25
    backfaceThreshold: 100
  m_SceneGUID: 00000000000000000000000000000000
  m_OcclusionCullingData: {fileID: 0}
--- !u!104 &2
RenderSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 9
  m_Fog: 0
  m_FogColor: {r: 0.5, g: 0.5, b: 0.5, a: 1}
  m_FogMode: 3
  m_FogDensity: 0.01
  m_LinearFogStart: 0
  m_LinearFogEnd: 300
  m_AmbientSkyColor: {r: 0.212, g: 0.227, b: 0.259, a: 1}
  m_AmbientEquatorColor: {r: 0.114, g: 0.125, b: 0.133, a: 1}
  m_AmbientGroundColor: {r: 0.047, g: 0.043, b: 0.035, a: 1}
  m_AmbientIntensity: 1
  m_AmbientMode: 0
  m_SubtractiveShadowColor: {r: 0.42, g: 0.478, b: 0.627, a: 1}
  m_SkyboxMaterial: {fileID: 10304, guid: 0000000000000000f000000000000000, type: 0}
  m_HaloStrength: 0.5
  m_FlareStrength: 1
  m_FlareFadeSpeed: 3
  m_HaloTexture: {fileID: 0}
  m_SpotCookie: {fileID: 10001, guid: 0000000000000000e000000000000000, type: 0}
  m_DefaultReflectionMode: 0
  m_DefaultReflectionResolution: 128
  m_ReflectionBounces: 1
  m_ReflectionIntensity: 1
  m_CustomReflection: {fileID: 0}
  m_Sun: {fileID: 705507994}
  m_IndirectSpecularColor: {r: 0, g: 0, b: 0, a: 1}
  m_UseRadianceAmbientProbe: 0
--- !u!157 &3
LightmapSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 11
  m_GIWorkflowMode: 1
  m_GISettings:
    serializedVersion: 2
    m_BounceScale: 1
    m_IndirectOutputScale: 1
    m_AlbedoBoost: 1
    m_EnvironmentLightingMode: 0
    m_EnableBakedLightmaps: 1
    m_EnableRealtimeLightmaps: 0
  m_LightmapEditorSettings:
    serializedVersion: 12
    m_Resolution: 2
    m_BakeResolution: 40
    m_AtlasSize: 1024
    m_AO: 0
    m_AOMaxDistance: 1
    m_CompAOExponent: 1
    m_CompAOExponentDirect: 0
    m_ExtractAmbientOcclusion: 0
    m_Padding: 2
    m_LightmapParameters: {fileID: 0}
    m_LightmapsBakeMode: 1
    m_TextureCompression: 1
    m_FinalGather: 0
    m_FinalGatherFiltering: 1
    m_FinalGatherRayCount: 256
    m_ReflectionCompression: 2
    m_MixedBakeMode: 2
    m_BakeBackend: 1
    m_PVRSampling: 1
    m_PVRDirectSampleCount: 32
    m_PVRSampleCount: 500
    m_PVRBounces: 2
    m_PVREnvironmentSampleCount: 500
    m_PVREnvironmentReferencePointCount: 2048
    m_PVRFilteringMode: 2
    m_PVRDenoiserTypeDirect: 0
    m_PVRDenoiserTypeIndirect: 0
    m_PVRDenoiserTypeAO: 0
    m_PVRFilterTypeDirect: 0
    m_PVRFilterTypeIndirect: 0
    m_PVRFilterTypeAO: 0
    m_PVREnvironmentMIS: 0
    m_PVRCulling: 1
    m_PVRFilteringGaussRadiusDirect: 1
    m_PVRFilteringGaussRadiusIndirect: 5
    m_PVRFilteringGaussRadiusAO: 2
    m_PVRFilteringAtrousPositionSigmaDirect: 0.5
    m_PVRFilteringAtrousPositionSigmaIndirect: 2
    m_PVRFilteringAtrousPositionSigmaAO: 1
    m_ExportTrainingData: 0
    m_TrainingDataDestination: TrainingData
    m_LightProbeSampleCountMultiplier: 4
  m_LightingDataAsset: {fileID: 0}
  m_UseShadowmask: 1
--- !u!196 &4
NavMeshSettings:
  serializedVersion: 2
  m_ObjectHideFlags: 0
  m_BuildSettings:
    serializedVersion: 2
    agentTypeID: 0
    agentRadius: 0.5
    agentHeight: 2
    agentSlope: 45
    agentClimb: 0.4
    ledgeDropHeight: 0
    maxJumpAcrossDistance: 0
    minRegionArea: 2
    manualCellSize: 0
    cellSize: 0.16666667
    manualTileSize: 0
    tileSize: 256
    accuratePlacement: 0
    debug:
      m_Flags: 0
  m_NavMeshData: {fileID: 0}
--- !u!1 &705507993
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 705507995}
  - component: {fileID: 705507994}
  m_Layer: 0
  m_Name: Directional Light
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!108 &705507994
Light:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 705507993}
  m_Enabled: 1
  serializedVersion: 10
  m_Type: 1
  m_Shape: 0
  m_Color: {r: 1, g: 0.95686275, b: 0.8392157, a: 1}
  m_Intensity: 1
  m_Range: 10
  m_SpotAngle: 30
  m_InnerSpotAngle: 21.80208
  m_CookieSize: 10
  m_Shadows:
    m_Type: 2
    m_Resolution: -1
    m_CustomResolution: -1
    m_Strength: 1
    m_Bias: 0.05
    m_NormalBias: 0.4
    m_NearPlane: 0.2
    m_CullingMatrixOverride:
      e00: 1
      e01: 0
      e02: 0
      e03: 0
      e10: 0
      e11: 1
      e12: 0
      e13: 0
      e20: 0
      e21: 0
      e22: 1
      e23: 0
      e30: 0
      e31: 0
      e32: 0
      e33: 1
    m_UseCullingMatrixOverride: 0
  m_Cookie: {fileID: 0}
  m_DrawHalo: 0
  m_Flare: {fileID: 0}
  m_RenderMode: 0
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingLayerMask: 1
  m_Lightmapping: 1
  m_LightShadowCasterMode: 0
  m_AreaSize: {x: 1, y: 1}
  m_BounceIntensity: 1
  m_ColorTemperature: 6570
  m_UseColorTemperature: 0
  m_BoundingSphereOverride: {x: 0, y: 0, z: 0, w: 0}
  m_UseBoundingSphereOverride: 0
  m_ShadowRadius: 0
  m_ShadowAngle: 0
--- !u!4 &705507995
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 705507993}
  m_LocalRotation: {x: 0.40821788, y: -0.23456968, z: 0.10938163, w: 0.8754261}
  m_LocalPosition: {x: 0, y: 3, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 50, y: -30, z: 0}
--- !u!1 &776302434
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 776302438}
  - component: {fileID: 776302437}
  - component: {fileID: 776302436}
  - component: {fileID: 776302435}
  m_Layer: 5
  m_Name: Canvas
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &776302435
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 776302434}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: dc42784cf147c0c48a680349fa168899, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_IgnoreReversedGraphics: 1
  m_BlockingObjects: 0
  m_BlockingMask:
    serializedVersion: 2
    m_Bits: 4294967295
--- !u!114 &776302436
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 776302434}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 0cd44c1031e13a943bb63640046fad76, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_UiScaleMode: 0
  m_ReferencePixelsPerUnit: 100
  m_ScaleFactor: 1
  m_ReferenceResolution: {x: 800, y: 600}
  m_ScreenMatchMode: 0
  m_MatchWidthOrHeight: 0
  m_PhysicalUnit: 3
  m_FallbackScreenDPI: 96
  m_DefaultSpriteDPI: 96
  m_DynamicPixelsPerUnit: 1
--- !u!223 &776302437
Canvas:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 776302434}
  m_Enabled: 1
  serializedVersion: 3
  m_RenderMode: 0
  m_Camera: {fileID: 0}
  m_PlaneDistance: 100
  m_PixelPerfect: 0
  m_ReceivesEvents: 1
  m_OverrideSorting: 0
  m_OverridePixelPerfect: 0
  m_SortingBucketNormalizedSize: 0
  m_AdditionalShaderChannelsFlag: 0
  m_SortingLayerID: 0
  m_SortingOrder: 0
  m_TargetDisplay: 0
--- !u!224 &776302438
RectTransform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 776302434}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 0, y: 0, z: 0}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 2
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
  m_AnchorMin: {x: 0, y: 0}
  m_AnchorMax: {x: 0, y: 0}
  m_AnchoredPosition: {x: 0, y: 0}
  m_SizeDelta: {x: 0, y: 0}
  m_Pivot: {x: 0, y: 0}
--- !u!1 &930832628
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 930832631}
  - component: {fileID: 930832630}
  - component: {fileID: 930832629}
  m_Layer: 0
  m_Name: EventSystem
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!114 &930832629
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 930832628}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4f231c4fb786f3946a6b90b886c48677, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_HorizontalAxis: Horizontal
  m_VerticalAxis: Vertical
  m_SubmitButton: Submit
  m_CancelButton: Cancel
  m_InputActionsPerSecond: 10
  m_RepeatDelay: 0.5
  m_ForceModuleActive: 0
--- !u!114 &930832630
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 930832628}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 76c392e42b5098c458856cdf6ecaaaa1, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
  m_FirstSelected: {fileID: 0}
  m_sendNavigationEvents: 1
  m_DragThreshold: 10
--- !u!4 &930832631
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 930832628}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 3
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &963194225
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 963194228}
  - component: {fileID: 963194227}
  - component: {fileID: 963194226}
  m_Layer: 0
  m_Name: Main Camera
  m_TagString: MainCamera
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!81 &963194226
AudioListener:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 963194225}
  m_Enabled: 1
--- !u!20 &963194227
Camera:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 963194225}
  m_Enabled: 1
  serializedVersion: 2
  m_ClearFlags: 1
  m_BackGroundColor: {r: 0.19215687, g: 0.3019608, b: 0.4745098, a: 0}
  m_projectionMatrixMode: 1
  m_GateFitMode: 2
  m_FOVAxisMode: 0
  m_SensorSize: {x: 36, y: 24}
  m_LensShift: {x: 0, y: 0}
  m_FocalLength: 50
  m_NormalizedViewPortRect:
    serializedVersion: 2
    x: 0
    y: 0
    width: 1
    height: 1
  near clip plane: 0.3
  far clip plane: 1000
  field of view: 60
  orthographic: 0
  orthographic size: 5
  m_Depth: -1
  m_CullingMask:
    serializedVersion: 2
    m_Bits: 4294967295
  m_RenderingPath: -1
  m_TargetTexture: {fileID: 0}
  m_TargetDisplay: 0
  m_TargetEye: 3
  m_HDR: 1
  m_AllowMSAA: 1
  m_AllowDynamicResolution: 0
  m_ForceIntoRT: 0
  m_OcclusionCulling: 1
  m_StereoConvergence: 10
  m_StereoSeparation: 0.022
--- !u!4 &963194228
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 963194225}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 1, z: -10}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!1 &2098148355
GameObject:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  serializedVersion: 6
  m_Component:
  - component: {fileID: 2098148356}
  - component: {fileID: 2098148357}
  m_Layer: 0
  m_Name: Launch
  m_TagString: Untagged
  m_Icon: {fileID: 0}
  m_NavMeshLayer: 0
  m_StaticEditorFlags: 0
  m_IsActive: 1
--- !u!4 &2098148356
Transform:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2098148355}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 4
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
--- !u!114 &2098148357
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 2098148355}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 4704b7bf40d81d642af874b88c1e94ba, type: 3}
  m_Name: 
  m_EditorClassIdentifier: 
--[[
* @author PureMVC LUA Native Port by Ravior 
* @author Copyright(c) 2006-2012 Futurescale, Inc., Some rights reserved.
* 
* @class puremvc.Controller
* 
* In PureMVC, the Controller class follows the 'Command and Controller' 
* strategy, and assumes these responsibilities:
* 
* - Remembering which
* {@link puremvc.SimpleCommand SimpleCommand}s
* or 
* {@link puremvc.MacroCommand MacroCommand}s
* are intended to handle which 
* {@link puremvc.Notification Notification}s
* - Registering itself as an 
* {@link puremvc.Observer Observer} with
* the {@link puremvc.View View} for each 
* {@link puremvc.Notification Notification}
* that it has an 
* {@link puremvc.SimpleCommand SimpleCommand} 
* or {@link puremvc.MacroCommand MacroCommand} 
* mapping for.
* - Creating a new instance of the proper 
* {@link puremvc.SimpleCommand SimpleCommand}s
* or 
* {@link puremvc.MacroCommand MacroCommand}s
* to handle a given 
* {@link puremvc.Notification Notification} 
* when notified by the
* {@link puremvc.View View}.
* - Calling the command's execute method, passing in the 
* {@link puremvc.Notification Notification}.
*
* Your application must register 
* {@link puremvc.SimpleCommand SimpleCommand}s
* or {@link puremvc.MacroCommand MacroCommand}s 
* with the Controller.
*
* The simplest way is to subclass 
* {@link puremvc.Facade Facade},
* and use its 
* {@link puremvc.Facade#initializeController initializeController} 
* method to add your registrations.
]]

Controller = class("Controller")


--[[
* @constructor
* This Controller implementation is a Multiton, so you should not call the 
* constructor directly, but instead call the static #getInstance factory method, 
* passing the unique key for this instance to it.
* @param {string} key
* @throws {Error}
*  If instance for this Multiton key has already been constructed
]]
function Controller:ctor(key)
	if self.instanceMap[key] ~= nil then
		error(Controller.MULTITON_MSG)
	end
	self.multitonKey = key
	Controller.instanceMap[self.multitonKey] = self
	self.commandMap = {}
	self:initializeController()
end


--[[
* @protected
* 
* Initialize the multiton Controller instance.
*
* Called automatically by the constructor.
*
* Note that if you are using a subclass of View
* in your application, you should*also* subclass Controller
* and override the initializeController method in the
* following way.
* 
*     MyController.prototype.initializeController= function ()
*     {
*         this.view= MyView.getInstance(this.multitonKey);
*     };
* 
* @return {void}
]]
function Controller:initializeController()
	self.view = View:getInstance(self.multitonKey)
end


--[[
* The Controllers multiton factory method. 
* Note that this method will return null if supplied a null 
* or undefined multiton key. 
*
* @param {string} key
*  A Controller's multiton key
* @return {puremvc.Controller}
*  the Multiton instance of Controller
]]
function  Controller:getInstance(key)
	if nil == key then
		return nil
	end

	if(nil == self.instanceMap[key]) then
		self.instanceMap[key] = self.new(key)
	end

	return self.instanceMap[key]
end


--[[
* If a SimpleCommand or MacroCommand has previously been registered to handle
* the given Notification then it is executed.
*
* @param {puremvc.Notification} note
* @return {void}
]]
function Controller:executeCommand(note)
	local commandClassRef = self.commandMap[note:getName()]
	if commandClassRef == nil then
		return
	end

	local commandInstance = commandClassRef.new()
	commandInstance:initializeNotifier(self.multitonKey)
	commandInstance:execute(note)
end


--[[
* Register a particular SimpleCommand or MacroCommand class as the handler for 
* a particular Notification.
*
* If an command already been registered to handle Notifications with this name, 
* it is no longer used, the new command is used instead.
*
* The Observer for the new command is only created if this the irst time a
* command has been regisered for this Notification name.
*
* @param {string} notificationName
*  the name of the Notification
* @param {Function} commandClassRef
*  a command constructor
* @return {void}
]]
function Controller:registerCommand(notificationName,commandClassRef)
	if self.commandMap[notificationName] == nil then
		self.view:registerObserver(notificationName,Observer.new(self.executeCommand,self))
	end

	self.commandMap[notificationName] = commandClassRef
end


--[[
* Check if a command is registered for a given Notification
*
* @param {string} notificationName
* @return {boolean}
*  whether a Command is currently registered for the given notificationName.
]]
function Controller:hasCommand(notificationName)
	return self.commandMap[notificationName] ~= nil
end


--[[
* Remove a previously registered command to
* {@link puremvc.Notification Notification}
* mapping.
*
* @param {string} notificationName
*  the name of the Notification to remove the command mapping for
* @return {void}
]]
function Controller:removeCommand(notificationName)
	if self:hasCommand(notificationName) ~= nil then
		self.view.removeObserver(notificationName,self)
		self.commandMap[notificationName] = nil
	end
end


--[[
* @static
* Remove a Controller instance.
*
* @param {string} key 
*  multitonKey of Controller instance to remove
* @return {void}
]]
function Controller:removeController(key)
	self.instanceMap[key] = nil
end


--[[
* @ignore
* The map used by the Model to store multiton instances
*
* @protected
* @static
* @type Array
]]
Controller.instanceMap = {}


--[[
* @ignore
* Message Constants
* 
* @static
* @type {string}
]]
Controller.MULTITON_MSG= "controller key for this Multiton key already constructed"--[[
* @author PureMVC LUA Native Port by Ravior 
* @author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
* 
* @class puremvc.Model
*
* A Multiton Model implementation.
*
* In PureMVC, the Model class provides
* access to model objects (Proxies) by named lookup.
*
* The Model assumes these responsibilities:
*
* - Maintain a cache of {@link puremvc.Proxy Proxy}
*   instances.
* - Provide methods for registering, retrieving, and removing
*   {@link puremvc.Proxy Proxy} instances.
*
* Your application must register 
* {@link puremvc.Proxy Proxy} instances with the Model. 
* Typically, you use a 
* {@link puremvc.SimpleCommand SimpleCommand} 
* or
* {@link puremvc.MacroCommand MacroCommand} 
* to create and register Proxy instances once the Facade has initialized the 
**Core* actors.
]]

Model = class("Model")


--[[
* This Model implementation is a Multiton, so you should not call the 
* constructor directly, but instead call the 
* {@link #getInstance static Multiton Factory method} 
* @constructor
* @param {string} key
*  The Models multiton key
* @throws {Error}
*  An error is thrown if this multitons key is already in use by another instance
]]
function Model:ctor(key)
	if Model.instanceMap[key] ~= nil then
		error(Model.MULTITON_MSG)
	end
	self.multitonKey = key
	Model.instanceMap[self.multitonKey] = self
	self.proxyMap = {}
	self:initializeModel()
end


--[[
* Initialize the Model instance.
* 
* Called automatically by the constructor, this
* is your opportunity to initialize the Singleton
* instance in your subclass without overriding the
* constructor.
* 
* @return void
]]
function Model:initializeModel() end


--[[
* Note that this method will return null if supplied a null 
* or undefined multiton key.
*  
* @param {string} key
*  The multiton key for the Model to retrieve
* @return {puremvc.Model}
*  the instance for this Multiton key 
]]
function Model:getInstance(key)
	if nil == key then
		return nil
	end
	if Model.instanceMap[key] == nil then
		return Model.new(key)
	else
		return Model.instanceMap[key]		
	end
end


--[[
* Register a Proxy with the Model
* @param {puremvc.Proxy}
]]
function Model:registerProxy(proxy)
	proxy:initializeNotifier(self.multitonKey)
	self.proxyMap[proxy:getProxyName()] = proxy
	proxy:onRegister()
end


--[[
* Retrieve a Proxy from the Model
* 
* @param {string} proxyName
* @return {puremvc.Proxy}
*  The Proxy instance previously registered with the provided proxyName
]]
function Model:retrieveProxy(proxyName)
	return self.proxyMap[proxyName]
end


--[[
* Check if a Proxy is registered
* @param {string} proxyName
* @return {boolean}
*  whether a Proxy is currently registered with the given proxyName.
]]
function Model:hasProxy(proxyName)
	return self.proxyMap[proxyName] ~= nil
end


--[[
* Remove a Proxy from the Model.
* 
* @param {string} proxyName
*  The name of the Proxy instance to remove
* @return {puremvc.Proxy}
*  The Proxy that was removed from the Model
]]
function Model:removeProxy(proxyName)
	local proxy = self.proxyMap[proxyName]
	if proxy ~= nil then
		self.proxyMap[proxyName] = nil
		proxy:onRemove()
	end
	return proxy
end


--[[
* @static
* Remove a Model instance.
* 
* @param {string} key
* @return {void}
]]
function Model:removeModel(key)
	self.instanceMap[key] = nil
end


--[[
* @ignore
* The map used by the Model to store Proxy instances.
*
* @protected
* @type Array
]]
Model.instanceMap = {}


--[[
* @ignore
* Message Constants
* 
* @static
* @type {string}
]]
Model.MULTITON_MSG= "Model instance for this Multiton key already constructed!";--[[
* @author PureMVC LUA Native Port by Ravior 
* @author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
* 
* @class puremvc.View
* 
* A Multiton View implementation.
* 
* In PureMVC, the View class assumes these responsibilities
* 
* - Maintain a cache of {@link puremvc.Mediator Mediator}
*   instances.
* 
* - Provide methods for registering, retrieving, and removing 
*   {@link puremvc.Mediator Mediator}.
* 
* - Notifiying {@link puremvc.Mediator Mediator} when they are registered or 
*   removed.
* 
* - Managing the observer lists for each {@link puremvc.Notification Notification}  
*   in the application.
* 
* - Providing a method for attaching {@link puremvc.Observer Observer} to an 
*   {@link puremvc.Notification Notification}'s observer list.
* 
* - Providing a method for broadcasting a {@link puremvc.Notification Notification}.
* 
* - Notifying the {@link puremvc.Observer Observer}s of a given 
*   {@link puremvc.Notification Notification} when it broadcast.
* 
* This View implementation is a Multiton, so you should not call the 
* constructor directly, but instead call the static Multiton 
* Factory #getInstance method
]]

View = class("View")


--[[
* @param {string} key
* @constructor
* @throws {Error} 
*  if instance for this Multiton key has already been constructed
]]
function View:ctor(key)
	if View.instanceMap[key] ~= nil then
		error(View.MULTITON_MSG)
	end
	self.multitonKey = key
	View.instanceMap[self.multitonKey] = self
	self.mediatorMap = {}
	self.observerMap = {}
	self:initializeView()
end


--[[
* @protected
* Initialize the Singleton View instance
* 
* Called automatically by the constructor, this is your opportunity to
* initialize the Singleton instance in your subclass without overriding the
* constructor
* 
* @return {void}
]]
function View:initializeView() end


--[[
* View Singleton Factory method.
* Note that this method will return null if supplied a null 
* or undefined multiton key.
*  
* @return {puremvc.View}
*  The Singleton instance of View
]]
function View:getInstance()
	if nil == key then
		return nil
	end
	if View.instanceMap[key] == nil then
		return View.new(key)
	else
		return View.instanceMap[key]		
	end
end


--[[
* Register an Observer to be notified of Notifications with a given name
* 
* @param {string} notificationName
*  The name of the Notifications to notify this Observer of
* @param {puremvc.Observer} observer
*  The Observer to register.
* @return {void}
]]
function View:registerObserver(notificationName,observer)
	if self.observerMap[notificationName] ~= nil then
		table.insert(self.observerMap[notificationName], observer)
	else
		self.observerMap[notificationName] = {observer}
	end
end


--[[
* Notify the Observersfor a particular Notification.
* 
* All previously attached Observers for this Notification's
* list are notified and are passed a reference to the INotification in 
* the order in which they were registered.
* 
* @param {puremvc.Notification} notification
*  The Notification to notify Observers of
* @return {void}
]]
function View:notifyObservers(notification)
	if self.observerMap[notification:getName()] ~= nil then
		local observers_ref = self.observerMap[notification:getName()]
		for _,o in pairs(observers_ref) do
			o:notifyObserver(notification)
		end
	end
end


--[[
* Remove the Observer for a given notifyContext from an observer list for
* a given Notification name
* 
* @param {string} notificationName
*  Which observer list to remove from
* @param {Object} notifyContext
*  Remove the Observer with this object as its notifyContext
* @return {void}
]]
function  View:removeObserver(notificationName,notifyContext)
	local observers = self.observerMap[notificationName]
	for _,o in pairs(observers) do
		if o:compareNotifyContext(context) then
			table.remove(observers,_)
			break
		end
	end

	if #observers == 0 then
		self.observerMap[notificationName] = nil
	end
end


--[[
* Register a Mediator instance with the View.
* 
* Registers the Mediator so that it can be retrieved by name,
* and further interrogates the Mediator for its 
* {@link puremvc.Mediator#listNotificationInterests interests}.
*
* If the Mediator returns any Notification
* names to be notified about, an Observer is created encapsulating 
* the Mediator instance's 
* {@link puremvc.Mediator#handleNotification handleNotification}
* method and registering it as an Observer for all Notifications the 
* Mediator is interested in.
* 
* @param {puremvc.Mediator} 
*  a reference to the Mediator instance
]]
function View:registerMediator(mediator)
	if self.mediatorMap[mediator:getMediatorName()] ~= nil then
		return
	end

	mediator:initializeNotifier(self.multitonKey)
	-- register the mediator for retrieval by name
	self.mediatorMap[mediator:getMediatorName()] = mediator

	-- get notification interests if any
	local interests = mediator:listNotificationInterests()

	-- register mediator as an observer for each notification
	if #interests > 0 then
		-- create observer referencing this mediators handleNotification method
		local observer = Observer.new(mediator.handleNotification,mediator)
		for _,i in pairs(interests) do
			self:registerObserver(i,observer)
		end
	end

	mediator:onRegister()
end


--[[
* Retrieve a Mediator from the View
* 
* @param {string} mediatorName
*  The name of the Mediator instance to retrieve
* @return {puremvc.Mediator}
*  The Mediator instance previously registered with the given mediatorName
]]
function View:retrieveMediator(mediatorName)
	return self.mediatorMap[mediatorName]
end


--[[
* Remove a Mediator from the View.
* 
* @param {string} mediatorName
*  Name of the Mediator instance to be removed
* @return {puremvc.Mediator}
*  The Mediator that was removed from the View
]]
function View:removeMediator(mediatorName)
	local mediator = self.mediatorMap[mediatorname]
	if mediator ~= nil then
		-- for every notification the mediator is interested in...
		local interests = mediator:listNotificationInterests()
		for _,i in pairs(interests) do
			-- remove the observer linking the mediator to the notification
            -- interest
			self:removeObserver(i,mediator)
		end

		-- remove the mediator from the map
		self.mediatorMap[mediatorName] = nil

		-- alert the mediator that it has been removed
		mediator:onRemove()
	end

	return mediator
end


--[[
* Check if a Mediator is registered or not.
* 
* @param {string} mediatorName
* @return {boolean}
*  Whether a Mediator is registered with the given mediatorname
]]
function View:hasMediator(mediatorName)
	return self.mediatorMap[mediatorName] ~= nil
end


--[[
* Remove a View instance
* 
* @return {void}
]]
function View.removeView(key)
	View.instanceMap[key] = nil
end


--[[
* @ignore
* The map used by the Model to store multiton instances
*
* @protected
* @static
* @type Array
]]
View.instanceMap = {}


--[[
* @ignore
* The error message used if an attempt is made to instantiate View directly
*
* @type string
* @protected
* @const
* @static
]]
View.MULTITON_MSG = "View instance for this Multiton key already constructed!"

--[[
@author PureMVC LUA Native Port by Ravior 
@author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
 
@hide
A an internal helper class used to assist classlet implementation. This
class is not accessible by client code.
]]

function class(classname, super)
	local superType = type(super)
	local cls
	if superType ~= 'function' and superType ~= 'table' then
		superType = nil
		super = nil
	end

	if superType == 'function' or (super and super.__ctype == 1) then
		-- inherited from native C++ Object
		cls = {}
		if superType == 'table' then
			-- copy fields from super
			for k,v in pairs(super) do cls[k] = v end
			cls.__create = super.__create
			cls.super = super
		else
			cls.__create = super
			cls.ctor = function() end
		end
		cls.__cname = classname
		cls.__ctype = 1

		function cls.new(...)
			local instance = cls.__create(...)
			-- copy fields from class to  native object
			for k, v in pairs(cls) do instance[k] = v end
			instance.class = cls
			instance:ctor(...)
			return instance
		end
	else
		-- inherited from Lua Object
		if super then
			cls = {}
			setmetatable(cls, {__index = super})
			cls.super = super
		else
			cls = {ctor = function() end}
		end
		cls.__cname = classname
		cls.__ctype = 2 --lua
		cls.__index = cls

		function cls.new(...)
			local instance = setmetatable({}, cls)
			instance.class = cls
			instance:ctor(...)
			return instance
		end
	end
	return cls
end
--[[
* @author PureMVC LUA Native Port by Ravior 
* @author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
* 
* @class puremvc.MacroCommand
* @extends puremvc.Notifier
* 
* A base command implementation that executes other commands, such as
* {@link puremvc.SimpleCommand SimpleCommand}
* or {@link puremvc.MacroCommand MacroCommand}
* subclasses.
*  
* A MacroCommand maintains an list of
* command constructor references called*SubCommands*.
* 
* When #execute is called, the MacroCommand
* instantiates and calls #execute on each of its*SubCommands* in turn.
* Each*SubCommand* will be passed a reference to the original
* {@link puremvc.Notification Notification} 
* that was passed to the MacroCommands #execute method
* 
* Unlike {@link puremvc.SimpleCommand SimpleCommand}, 
* your subclass should not override #execute but instead, should 
* override the #initializeMacroCommand method, calling #addSubCommand once for 
* each*SubCommand* to be executed.
]]

MacroCommand = class("MacroCommand",Notifier)


--[[
* If your subclass does define a constructor, be sure to call "super" like so
* 
*     function MyMacroCommand ()
*     {
*         MacroCommand.call(this);
*     };
* @constructor
]]
function MacroCommand:ctor()
	self.subCommands = {}
	self:initializeMacroCommand()
end


--[[
* @protected
* Initialize the MacroCommand.
* 
* In your subclass, override this method to 
* initialize the MacroCommand's*SubCommand*  
* list with command class references like 
* this:
* 
*     // Initialize MyMacroCommand
*     MyMacroCommand.prototype.initializeMacroCommand= function ()
*     {
*         this.addSubCommand( com.me.myapp.controller.FirstCommand );
*         this.addSubCommand( com.me.myapp.controller.SecondCommand );
*         this.addSubCommand( com.me.myapp.controller.ThirdCommand );
*     };
* 
* Note that*SubCommand*s may be any command implementor,
* MacroCommands or SimpleCommands are both acceptable.
* @return {void}
]]
function MacroCommand:initializeMacroCommand() end


--[[
* @protected
* Add a*SubCommand*
* 
* The*SubCommand*s will be called in First In / First Out (FIFO) order
* @param {Function} commandClassRef
*  A reference to a subclassed SimpleCommand or MacroCommand constructor
]]
function MacroCommand:addSubCommand(commandClassRef)
	table.insert(self.subCommands, commandClassRef)
end


--[[
* Execute this MacroCommands*SubCommands*
* 
* The*SubCommand*s will be called in First In / First Out (FIFO) order
* @param {puremvc.Notification} note
*  The Notification object to be passed to each*SubCommand*
]]
function MacroCommand:execute(note)
	while(#self.subCommands > 0) do
        local ref = table.remove(self.subCommands)
        local cmd = ref.new()
        cmd:initializeNotifier(self.multitonKey)
        cmd:execute(note)
    end
end--[[
* @author PureMVC LUA Native Port by Ravior  
* @author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
* 
* @class puremvc.SimpleCommand
* @extends puremvc.Notifier
*
* SimpleCommands encapsulate the business logic of your application. Your 
* subclass should override the #execute method where your business logic will
* handle the 
* {@link puremvc.Notification Notification}
* 
* Take a look at 
* {@link puremvc.Facade#registerCommand Facade's registerCommand}
* or {@link puremvc.Controller#registerCommand Controllers registerCommand}
* methods to see how to add commands to your application.
]]

SimpleCommand = class("SimpleCommand",Notifier)


--[[
* @constructor
]]
function SimpleCommand:ctor() end


--[[
 Fulfill the use-case initiated by the given Notification
* 
* In the Command Pattern, an application use-case typically begins with some
* user action, which results in a Notification is handled by the business logic
* in the #execute method of a command.
* 
* @param {puremvc.Notification} notification
*  The notification to handle.
* @return {void}
]]
function SimpleCommand:execute(notification) end--[[
* @author PureMVC LUA Native Port by Ravior 
* @author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
* 
* @class puremvc.Facade
* Facade exposes the functionality of the Controller, Model and View
* actors to client facing code. 
* 
* This Facade implementation is a Multiton, so you should not call the 
* constructor directly, but instead call the static Factory method, 
* passing the unique key for this instance to #getInstance
]]

Facade = class("Facade")


--[[
* @constructor
* @param {string} key
* 	The multiton key to use to retrieve the Facade instance.
* @throws {Error} 
*  If an attempt is made to instantiate Facade directly
]]
function Facade:ctor(key)
	if Facade.instanceMap[key] ~= nil then
		error(Facade.MULTITON_MSG)
	end
	self:initializeNotifier(key)
	Facade.instanceMap[key] = self
	self:initializeFacade()
end


--[[
* Initialize the Multiton Facade instance.
* 
* Called automatically by the constructor. Override in your subclass to any
* subclass specific initializations. Be sure to call the 'super' 
* initializeFacade method, though
* 
*     MyFacade.prototype.initializeFacade= function ()
*     {
*         Facade.call(this);
*     };
* @protected
* @return {void}
]]
function Facade:initializeFacade()
	self:initializeModel()
	self:initializeController()
	self:initializeView()
end


--[[
* Facade Multiton Factory method. 
* Note that this method will return null if supplied a
* null or undefined multiton key.
* 
* @param {string} key
* 	The multiton key use to retrieve a particular Facade instance
* @return {puremvc.Facade}
]]
function Facade:getInstance(key)
	if nil == key then 
		return nil
	end

	if Facade.instanceMap[key] == nil then
		Facade.instanceMap[key] = Facade.new(key)
	end

	return Facade.instanceMap[key]
end


--[[
* Initialize the {@link puremvc.Controller Controller}.
* 
* Called by the #initializeFacade method.
* 
* Override this method in your subclass of Facade
* if one or both of the following are true:
* - You wish to initialize a different Controller
* - You have 
* {@link puremvc.SimpleCommand SimpleCommand}s
* or {@link puremvc.MacroCommand MacroCommand}s
* to register with the Controllerat startup.   
* 
* If you don't want to initialize a different Controller, 
* call the 'super' initializeControlle method at the beginning of your
* method, then register commands.
* 
*     MyFacade.prototype.initializeController= function ()
*     {
*         Facade.prototype.initializeController.call(this);
*         this.registerCommand(AppConstants.A_NOTE_NAME, ABespokeCommand)
*     }
* 
* @protected
* @return {void}
]]
function Facade:initializeController()
	if self.controller ~= nil then
		return
	end

	self.controller = Controller:getInstance(self.multitonKey)
end


--[[
* @protected
* Initialize the {@link puremvc.Model Model};
* 
* Called by the #initializeFacade method.
* Override this method in your subclass of Facade if one of the following are
* true:
* 
* - You wish to initialize a different Model.
* 
* - You have {@link puremvc.Proxy Proxy}s to 
*   register with the Model that do not retrieve a reference to the Facade at 
*   construction time.
* 
* If you don't want to initialize a different Model
* call 'super' #initializeModel at the beginning of your method, then register 
* Proxys.
* 
* Note: This method is*rarely* overridden; in practice you are more
* likely to use a command to create and registerProxys with the Model>, 
* since Proxys with mutable data will likely
* need to send Notifications and thus will likely want to fetch a reference to 
* the Facade during their construction. 
* 
* @return {void}
]]
function Facade:initializeModel()
	if self.model ~= nil then
		return
	end

	self.model = Model:getInstance(self.multitonKey)
end


--[[
* @protected
* 
* Initialize the {@link puremvc.View View}.
* 
* Called by the #initializeFacade method.
* 
* Override this method in your subclass of Facade if one or both of the 
* following are true:
*
* - You wish to initialize a different View.
* - You have Observers to register with the View
* 
* If you don't want to initialize a different View 
* call 'super' #initializeView at the beginning of your
* method, then register Mediator instances.
* 
*     MyFacade.prototype.initializeView= function ()
*     {
*         Facade.prototype.initializeView.call(this);
*         this.registerMediator(new MyMediator());
*     };
* 
* Note: This method is*rarely* overridden; in practice you are more
* likely to use a command to create and register Mediators
* with the View, since Mediator instances will need to send 
* Notifications and thus will likely want to fetch a reference 
* to the Facade during their construction. 
* @return {void}
]]
function Facade:initializeView()
	if self.view ~= nil then
		return
	end

	self.view = View:getInstance(self.multitonKey)
end


--[[
* Register a command with the Controller by Notification name
* @param {string} notificationName
*  The name of the Notification to associate the command with
* @param {Function} commandClassRef
*  A reference ot the commands constructor.
* @return {void}
]]
function Facade:registerCommand(notificationName,commandClassRef)
	self.controller:registerCommand(notificationName,commandClassRef)
end


--[[
* Remove a previously registered command to Notification mapping from the
* {@link puremvc.Controller#removeCommand Controller}
* @param {string} notificationName
*  The name of the the Notification to remove from the command mapping for.
* @return {void}
]]
function Facade:removeCommand(notificationName)
	self.controller:removeCommand(notificationName)
end


--[[
* Check if a command is registered for a given notification.
* 
* @param {string} notificationName
*  A Notification name
* @return {boolean}
*  Whether a comman is currently registered for the given notificationName
]]
function Facade:hasCommand(notificationName)
	return self.controller:hasCommand(notificationName)
end


--[[
* Register a Proxy with the {@link puremvc.Model#registerProxy Model}
* by name.
* 
* @param {puremvc.Proxy} proxy
*  The Proxy instance to be registered with the Model.
* @return {void}
]]
function Facade:registerProxy(proxy)
	self.model:registerProxy(proxy)
end


--[[
* Retrieve a Proxy from the Model
* 
* @param {string} proxyName
* @return {puremvc.Proxy}
]]
function Facade:retrieveProxy(proxyName)
	return self.model:retrieveProxy(proxyName)
end


--[[
* Remove a Proxy from the Model by name
* @param {string} proxyName
*  The name of the Proxy
* @return {puremvc.Proxy}
*  The Proxy that was removed from the Model
]]
function Facade:removeProxy(proxyName)
	local proxy = nil
	if self.model ~= nil then
		proxy = self.model:removeProxy(proxyName)
	end

	return proxy
end


--[[
* Check it a Proxy is registered.
* @param {string} proxyName
*  A Proxy name
* @return {boolean}
*  Whether a Proxy is currently registered with the given proxyName
]]
function Facade:hasProxy(proxyName)
	return self.model:hasProxy(proxyName)
end


--[[
* Register a Mediator with with the View.
* 
* @param {puremvc.Mediator} mediator
*  A reference to the Mediator to register
* @return {void}
]]
function Facade:registerMediator(mediator)
	if self.view ~= nil then
		self.view:registerMediator(mediator)
	end
end


--[[
* Retrieve a Mediator from the View by name
* 
* @param {string} mediatorName
*  The Mediators name
* @return {puremvc.Mediator}
*  The retrieved Mediator
]]
function Facade:retrieveMediator(mediatorName)
	return self.view:retrieveMediator(mediatorName)
end


--[[
* Remove a Mediator from the View.
* 
* @param {string} mediatorName
*  The name of the Mediator to remove.
* @return {puremvc.Mediator}
*  The removed Mediator
]]
function Facade:removeMediator(mediatorName)
	local mediator = nil
	if self.view ~= nil then
		mediator = self.view.removeMediator(mediatorName)
	end

	return mediator
end


--[[
* Check if a Mediator is registered or not.
* 
* @param {string} mediatorName
*  A Mediator name
* @return {boolean}
*  Whether a Mediator is registered with the given mediatorName
]]
function Facade:hasMediator(mediatorName)
	return self.view:hasMediator(mediatorName)
end


--[[
* Create and send a 
* {@link puremvc.Notification Notification}
* 
* Keeps us from having to construct new Notification instances in our
* implementation
* 
* @param {string} notificationName
*  The name of the Notification to send
* @param {Object} [body]
*  The body of the notification
* @param {string} [type]
*  The type of the notification
* @return {void}
]]
function Facade:sendNotification(notificationName,body,type)
	self:notifyObservers(Notification.new(notificationName,body,type))
end


--[[
* Notify {@link puremvc.Observer Observer}s
* 
* This method is left public mostly for backward compatibility, and to allow
* you to send custom notification classes using the facade.
* 
* Usually you should just call sendNotification and pass the parameters, never 
* having to construct the notification yourself.
* 
* @param {puremvc.Notification} notification
*  The Notification to send
* @return {void}
]]
function Facade:notifyObservers(notification)
	if self.view ~= nil then
		self.view.notifyObservers(notification)
	end
end


--[[
* Initialize the Facades Notifier capabilities by setting the Multiton key for 
* this facade instance.
* 
* Not called directly, but instead from the constructor when #getInstance is 
* invoked. It is necessary to be public in order to implement Notifier
* 
* @param {string} key
* @return {void}
]]
function Facade:initializeNotifier(key)
	self.multitonKey = key
end


--[[
* Check if a*Core* is registered or not
*
* @static
* @param {string} key
*  The multiton key for the*Core* in question
* @return {boolean}
*  Whether a*Core* is registered with the given key
]]
function Facade:hasCore(key)
	return Facade.instanceMap[key] ~= nil
end


--[[
* Remove a*Core* 
* 
* Remove the Model, View, Controller and Facade for a given key.
*
* @static
* @param {string} key
* @return {void}
]]
function Facade:removeCore(key)
	if Facade.instanceMap[key] == nil then
		return
	end

	Model:removeModel(key)
	View:removeView(key)
	Controller:removeController(key)
	Facade.instanceMap[key] = nil
end


--[[
* @ignore
* The Multiton Facade instance map.
* @static
* @protected
* @type Array
]]
Facade.instanceMap = {}


--[[
* @ignore
* Message Constants
* @protected
* @type {string}
* @const
* @static
]]
Facade.MULTITON_MSG = "Facade instance for this Multiton key already constructed!";--[[
* @author PureMVC LUA Native Port by Ravior 
* @author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
* 
* @class puremvc.Mediator
* @extends puremvc.Notifier
* 
* A base Mediator implementation.
*
* In PureMVC, Mediator classes are used to mediate communication between a view 
* component and the rest of the application.
*
* A Mediator should listen to its view components for events, and handle them 
* by sending notifications (to be handled by other Mediators, 
* {@link puremvc.SimpleCommand SimpleCommands} 
* or
* {@link puremvc.MacroCommand MacroCommands}) 
* or passing data from the view component directly to a 
* {@link puremvc.Proxy Proxy}, such as submitting 
* the contents of a form to a service.
* 
* Mediators should not perform business logic, maintain state or other 
* information for its view component, or break the encapsulation of the view 
* component by manipulating the view component's children. It should only call 
* methods or set properties on the view component.
*  
* The view component should encapsulate its own behavior and implementation by 
* exposing methods and properties that the Mediator can call without having to 
* know about the view component's children.
]]

Mediator = class("Mediator",Notifier)


--[[
* @constructor
* @param {string} [mediatorName]
*  The Mediators name. The Mediators static #NAME value is used by default
* @param {Object} [viewComponent]
*  The Mediators {@link #setViewComponent viewComponent}.
]]
function Mediator:ctor(mediatorName,viewComponent)
	self.mediatorName = mediatorName or Mediator.NAME
	self.viewComponent = viewComponent
end


--[[
* @static
* The name of the Mediator.
* 
* Typically, a Mediator will be written to serve one specific control or group
* of controls and so, will not have a need to be dynamically named.
* 
* @type {string}
]]
Mediator.NAME= "Mediator";


--[[
* Get the name of the Mediator
* 
* @return {string}
*  The Mediator name
]]
function Mediator:getMediatorName()
	return self.mediatorName
end


--[[
* Set the Mediators view component. This could
* be a HTMLElement, a bespoke UiComponent wrapper
* class, a MooTools Element, a jQuery result or a
* css selector, depending on which DOM abstraction 
* library you are using.
* 
* 
* @param {Object} the view component
* @return {void}
]]
function Mediator:setViewComponent(viewComponent)
	self.viewComponent = viewComponent
end


--[[
* Get the Mediators view component.
* 
* Additionally, an optional explicit getter can be
* be defined in the subclass that defines the 
* view components, providing a more semantic interface
* to the Mediator.
* 
* This is different from the AS3 implementation in
* the sense that no casting is required from the
* object supplied as the view component.
* 
*     MyMediator.prototype.getComboBox= function ()
*     {
*         return this.viewComponent;  
*     }
* 
* @return {Object}
*  The view component
]]
function  Mediator:getViewComponent()
	return self.viewComponent
end


--[[
* List the Notification names this Mediator is interested
* in being notified of.
* 
* @return {Array} 
*  The list of Notification names
]]
function Mediator:listNotificationInterests()
	return {}
end


--[[
* Handle Notifications.
* 
* Typically this will be handled in a switch statement
* with one 'case' entry per Notification the Mediator
* is interested in
* 
* @param {puremvc.Notification} notification
* @return {void}
]]
function Mediator:handleNotification(notification)
end


--[[
* Called by the View when the Mediator is registered
* @return {void}
]]
function Mediator:onRegister() end


--[[
* Called by the View when the Mediator is removed
]]
function Mediator:onRemove() end--[[
* @author PureMVC LUA Native Port by Ravior 
* @author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
* 
* @class puremvc.Notification
* 
* A base Notification implementation.
* 
* PureMVC does not rely upon underlying event models such as the one provided 
* with the DOM or other browser centric W3C event models.
* 
* The Observer Pattern as implemented within PureMVC exists to support 
* event-driven communication between the application and the actors of the MVC 
* triad.
* 
* Notifications are not meant to be a replacement for events in the browser. 
* Generally, Mediator implementors place event listeners on their view 
* components, which they then handle in the usual way. This may lead to the 
* broadcast of Notifications to trigger commands or to communicate with other 
* Mediators. {@link puremvc.Proxy Proxy},
* {@link puremvc.SimpleCommand SimpleCommand}
* and {@link puremvc.MacroCommand MacroCommand}
* instances communicate with each other and 
* {@link puremvc.Mediator Mediator}s
* by broadcasting Notifications.
* 
* A key difference between browser events and PureMVC Notifications is that
* events follow the 'Chain of Responsibility' pattern, 'bubbling' up the 
* display hierarchy until some parent component handles the event, while 
* PureMVC Notification follow a 'Publish/Subscribe' pattern. PureMVC classes 
* need not be related to each other in a parent/child relationship in order to 
* communicate with one another using Notifications.
* 
]]

Notification = class("Notification")


--[[
* @constructor 
* @param {string} name
*  The Notification name
* @param {Object} [body]
*  The Notification body
* @param {Object} [type]
*  The Notification type
]]
function Notification:ctor(name,body,type)
	self.name = name
	self.body = body
	self.type = type
end


--[[
* Get the name of the Notification instance
*
* @return {string}
*  The name of the Notification instance
]]
function Notification:getName()
	return self.name
end


--[[
* Set this Notifications body. 
* @param {Object} body
* @return {void}
]]
function Notification:setBody(body)
	self.body = body
end


--[[
* Get the Notification body.
*
* @return {Object}
]]
function Notification:getBody()
	return self.body
end


--[[
* Set the type of the Notification instance.
*
* @param {Object} type
* @return {void}
]]
function Notification:setType(type)
	self.type = type
end


--[[
* Get the type of the Notification instance.
* 
* @return {Object}
]]
function Notification:getType()
	return self.type
end


--[[
* Get a string representation of the Notification instance
*
* @return {string}
]]
function Notification:toString()
	local msg= "Notification Name: " .. self:getName()
    msg = msg .. "\nBody:" .. tostring(self:getBody())
    msg = msg .. "\nType:" .. tostring(self:getType())
    return msg;
end--[[
* @author PureMVC LUA Native Port by Ravior 
* @author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
* 
* @class puremvc.Notifier
* 
* A Base Notifier implementation.
* 
* {@link puremvc.MacroCommand MacroCommand}, 
* {@link puremvc.SimpleCommand SimpleCommand}, 
* {@link puremvc.Mediator Mediator} and 
* {@link puremvc.Proxy Proxy}
* all have a need to send Notifications
* 
* The Notifier interface provides a common method called #sendNotification that 
* relieves implementation code of the necessity to actually construct 
* Notifications.
* 
* The Notifier class, which all of the above mentioned classes
* extend, provides an initialized reference to the 
* {@link puremvc.Facade Facade}
* Multiton, which is required for the convienience method
* for sending Notifications but also eases implementation as these
* classes have frequent 
* {@link puremvc.Facade Facade} interactions 
* and usually require access to the facade anyway.
* 
* NOTE: In the MultiCore version of the framework, there is one caveat to
* notifiers, they cannot send notifications or reach the facade until they
* have a valid multitonKey. 
* 
* The multitonKey is set:
*   - on a Command when it is executed by the Controller
*   - on a Mediator is registered with the View
*   - on a Proxy is registered with the Model. 
]]

Notifier = class("Notifier")


--[[
* @constructor 
]]
function Notifier:ctor() end


--[[
* Create and send a Notification.
*
* Keeps us from having to construct new Notification instances in our 
* implementation code.
* 
* @param {string} notificationName
*  A notification name
* @param {Object} [body]
*  The body of the notification
* @param {string} [type]
*  The notification type
* @return {void}
]]
function Notifier:sendNotification(notificationName,body,type)
	local facade = self:getFacade()
	if facade ~= nil then
		facade:sendNotification(notificationName,body,type)
	end
end


--[[
* Initialize this Notifier instance.
* 
* This is how a Notifier gets its multitonKey. 
* Calls to #sendNotification or to access the
* facade will fail until after this method 
* has been called.
* 
* Mediators, Commands or Proxies may override 
* this method in order to send notifications
* or access the Multiton Facade instance as
* soon as possible. They CANNOT access the facade
* in their constructors, since this method will not
* yet have been called.
* 
*
* @param {string} key
*  The Notifiers multiton key;
* @return {void}
]]
function Notifier:initializeNotifier(key)
	self.multitonKey = tostring(key)
	self.facade = self:getFacade()
end


--[[
* Retrieve the Multiton Facade instance
*
*
* @protected
* @return {puremvc.Facade}
]]
function Notifier:getFacade()
	if self.multitonKey == nil then
		error(Notifier.MULTITON_MSG)
	end
	return Facade:getInstance(this.multitonKey);
end


--[[
* @ignore
* The error message used if the Notifier is not initialized correctly and
* attempts to retrieve its own multiton key
*
* @static
* @protected
* @const
* @type string
]]
Notifier.MULTITON_MSG = "multitonKey for this Notifier not yet initialized!";--[[
* @author PureMVC LUA Native Port by Ravior 
* @author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
* 
* @class puremvc.Observer
* 
* A base Observer implementation.
* 
* An Observer is an object that encapsulates information
* about an interested object with a method that should 
* be called when a particular Notification is broadcast. 
* 
* In PureMVC, the Observer class assumes these responsibilities:
* 
* - Encapsulate the notification (callback) method of the interested object.
* - Encapsulate the notification context (this) of the interested object.
* - Provide methods for setting the notification method and context.
* - Provide a method for notifying the interested object.
* 
]]

Observer = class("Observer")


--[[
* @constructor 
* @param {Function} notifyMethod 
*  the notification method of the interested object
* @param {Object} notifyContext 
*  the notification context of the interested object
* @constructor
]]
function Observer:ctor(notifyMethod,notifyContext)
	self:setNotifyMethod(notifyMethod)
	self:setNotifyContext(notifyContext)
end


--[[
* Set the Observers notification method.
* 
* The notification method should take one parameter of type Notification
* @param {Function} notifyMethod
*  the notification (callback) method of the interested object.
* @return {void}
]]
function Observer:setNotifyMethod(notifyMethod)
	self.notify = notifyMethod
end


--[[
* Set the Observers notification context.
* 
* @param {Object} notifyContext
*  the notification context (this) of the interested object.
* 
* @return {void}
]]
function Observer:setNotifyContext(notifyContext)
	self.context = notifyContext
end


--[[
* Get the Function that this Observer will invoke when it is notified.
* 
* @private
* @return {Function}
]]
function Observer:getNotifyMethod()
	return self.notify
end


--[[
* Get the Object that will serve as the Observers callback execution context
* 
* @private
* @return {Object}
]]
function Observer:getNotifyContext()
	return self.context
end


--[[
* Notify the interested object.
* 
* @param {puremvc.Notification} notification
*  The Notification to pass to the interested objects notification method
* @return {void}
]]
function Observer:notifyObserver(notification)
	self.notify(self.context,notification)
end


--[[
* Compare an object to this Observers notification context.
* 
* @param {Object} object
*  
* @return {boolean}
]]
function Observer:compareNotifyContext(object)
	return object == self.context
end
--[[
* @author PureMVC LUA Native Port by Ravior 
* @author Copyright(c) 2015 Gitlib, Inc., Some rights reserved.
* 
* @class puremvc.Proxy
* @extends puremvc.Notifier
*
* A base Proxy implementation. 
* 
* In PureMVC, Proxy classes are used to manage parts of the application's data 
* model.
* 
* A Proxy might simply manage a reference to a local data object, in which case 
* interacting with it might involve setting and getting of its data in 
* synchronous fashion.
* 
* Proxy classes are also used to encapsulate the application's interaction with 
* remote services to save or retrieve data, in which case, we adopt an 
* asyncronous idiom; setting data (or calling a method) on the Proxy and 
* listening for a 
* {@link puremvc.Notification Notification} 
* to be sent  when the Proxy has retrieved the data from the service.
]]

Proxy = class("Proxy",Notifier)


--[[
* @constructor
* @param {string} [proxyName]
*  The Proxy's name. If none is provided, the Proxy will use its constructors
*  NAME property.
* @param {Object} [data]
*  The Proxy's data object
]]
function Proxy:ctor(proxyName,data)
	self.proxyName = proxyName or Proxy.NAME
	if data ~= nil then
		self:setData(data)
	end
end


Proxy.NAME= "Proxy"


--[[
* Get the Proxy's name.
*
* @return {string}
]]
function Proxy:getProxyName()
	return self.proxyName
end


--[[
* Set the Proxy's data object
*
* @param {Object} data
* @return {void}
]]
function Proxy:setData(data)
	self.data = data
end


--[[
* Get the Proxy's data object
*
* @return {Object}
]]
function  Proxy:getData()
	return self.data
end


--[[
* Called by the {@link puremvc.Model Model} when
* the Proxy is registered.
*
* @return {void}
]]
function Proxy:onRegister() end


--[[
* Called by the {@link puremvc.Model Model} when
* the Proxy is removed.
* 
* @return {void}
]]
function Proxy:onRemove() end


{
    "ID": "PureMVC@v1.0.0",
    "Name": "PureMVC",
    "Version": "v1.0.0",
    "liveWithOtherVersion": false,
    "Author": "ks",
    "Contact": "ks@keenlove.com",
    "HomePage": "https://github.com/keenlovelife",
    "Date": "2021-10-30 21:01:36",
    "Description": "PureMVC框架，提供C#和Lua实现的PureMVC框架。",
    "Dependencies": [],
    "Tags": [
        "PureMVC"
    ],
    "FileSettings": []
}{
    "dir": "D:/Mine/Repositories/KSwordKit/.KSwordKit/.KSwordKitLocalResource/Framework/PureMVC@v1.0.0",
    "fileBytesLength": 191722,
    "fileCount": 46,
    "fileIndexList": [
        {
            "isDir": true,
            "fileName": "C#",
            "relativeFilePath": "C#",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "Core",
            "relativeFilePath": "C#/Core",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "Controller.cs",
            "relativeFilePath": "C#/Core/Controller.cs",
            "fileBytesLength": 8722,
            "filePosition": 0
        },
        {
            "isDir": false,
            "fileName": "Model.cs",
            "relativeFilePath": "C#/Core/Model.cs",
            "fileBytesLength": 6110,
            "filePosition": 8722
        },
        {
            "isDir": false,
            "fileName": "View.cs",
            "relativeFilePath": "C#/Core/View.cs",
            "fileBytesLength": 11397,
            "filePosition": 14832
        },
        {
            "isDir": true,
            "fileName": "Interfaces",
            "relativeFilePath": "C#/Interfaces",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "ICommand.cs",
            "relativeFilePath": "C#/Interfaces/ICommand.cs",
            "fileBytesLength": 677,
            "filePosition": 26229
        },
        {
            "isDir": false,
            "fileName": "IController.cs",
            "relativeFilePath": "C#/Interfaces/IController.cs",
            "fileBytesLength": 3037,
            "filePosition": 26906
        },
        {
            "isDir": false,
            "fileName": "IFacade.cs",
            "relativeFilePath": "C#/Interfaces/IFacade.cs",
            "fileBytesLength": 5607,
            "filePosition": 29943
        },
        {
            "isDir": false,
            "fileName": "IMediator.cs",
            "relativeFilePath": "C#/Interfaces/IMediator.cs",
            "fileBytesLength": 3580,
            "filePosition": 35550
        },
        {
            "isDir": false,
            "fileName": "IModel.cs",
            "relativeFilePath": "C#/Interfaces/IModel.cs",
            "fileBytesLength": 2080,
            "filePosition": 39130
        },
        {
            "isDir": false,
            "fileName": "INotification.cs",
            "relativeFilePath": "C#/Interfaces/INotification.cs",
            "fileBytesLength": 2964,
            "filePosition": 41210
        },
        {
            "isDir": false,
            "fileName": "INotifier.cs",
            "relativeFilePath": "C#/Interfaces/INotifier.cs",
            "fileBytesLength": 2649,
            "filePosition": 44174
        },
        {
            "isDir": false,
            "fileName": "IObserver.cs",
            "relativeFilePath": "C#/Interfaces/IObserver.cs",
            "fileBytesLength": 3389,
            "filePosition": 46823
        },
        {
            "isDir": false,
            "fileName": "IProxy.cs",
            "relativeFilePath": "C#/Interfaces/IProxy.cs",
            "fileBytesLength": 1992,
            "filePosition": 50212
        },
        {
            "isDir": false,
            "fileName": "IView.cs",
            "relativeFilePath": "C#/Interfaces/IView.cs",
            "fileBytesLength": 4864,
            "filePosition": 52204
        },
        {
            "isDir": true,
            "fileName": "Patterns",
            "relativeFilePath": "C#/Patterns",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "Command",
            "relativeFilePath": "C#/Patterns/Command",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "MacroCommand.cs",
            "relativeFilePath": "C#/Patterns/Command/MacroCommand.cs",
            "fileBytesLength": 5169,
            "filePosition": 57068
        },
        {
            "isDir": false,
            "fileName": "SimpleCommand.cs",
            "relativeFilePath": "C#/Patterns/Command/SimpleCommand.cs",
            "fileBytesLength": 1577,
            "filePosition": 62237
        },
        {
            "isDir": true,
            "fileName": "Facade",
            "relativeFilePath": "C#/Patterns/Facade",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "Facade.cs",
            "relativeFilePath": "C#/Patterns/Facade/Facade.cs",
            "fileBytesLength": 15176,
            "filePosition": 63814
        },
        {
            "isDir": true,
            "fileName": "Mediator",
            "relativeFilePath": "C#/Patterns/Mediator",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "Mediator.cs",
            "relativeFilePath": "C#/Patterns/Mediator/Mediator.cs",
            "fileBytesLength": 2774,
            "filePosition": 78990
        },
        {
            "isDir": true,
            "fileName": "Observer",
            "relativeFilePath": "C#/Patterns/Observer",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "Notification.cs",
            "relativeFilePath": "C#/Patterns/Observer/Notification.cs",
            "fileBytesLength": 3645,
            "filePosition": 81764
        },
        {
            "isDir": false,
            "fileName": "Notifier.cs",
            "relativeFilePath": "C#/Patterns/Observer/Notifier.cs",
            "fileBytesLength": 4746,
            "filePosition": 85409
        },
        {
            "isDir": false,
            "fileName": "Observer.cs",
            "relativeFilePath": "C#/Patterns/Observer/Observer.cs",
            "fileBytesLength": 3091,
            "filePosition": 90155
        },
        {
            "isDir": true,
            "fileName": "Proxy",
            "relativeFilePath": "C#/Patterns/Proxy",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "Proxy.cs",
            "relativeFilePath": "C#/Patterns/Proxy/Proxy.cs",
            "fileBytesLength": 2404,
            "filePosition": 93246
        },
        {
            "isDir": true,
            "fileName": "Example",
            "relativeFilePath": "Example",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "Examples-puremvc-lua-framework",
            "relativeFilePath": "Example/Examples-puremvc-lua-framework",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "ExamplesPureMVCLuaFrameworkTest.cs",
            "relativeFilePath": "Example/Examples-puremvc-lua-framework/ExamplesPureMVCLuaFrameworkTest.cs",
            "fileBytesLength": 244,
            "filePosition": 95650
        },
        {
            "isDir": false,
            "fileName": "ExamplesPureMVCLuaFrameworkTestScene.unity",
            "relativeFilePath": "Example/Examples-puremvc-lua-framework/ExamplesPureMVCLuaFrameworkTestScene.unity",
            "fileBytesLength": 8405,
            "filePosition": 95894
        },
        {
            "isDir": true,
            "fileName": "ExamplesPureMVC",
            "relativeFilePath": "Example/ExamplesPureMVC",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "Controller",
            "relativeFilePath": "Example/ExamplesPureMVC/Controller",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "StartUPCommand.cs",
            "relativeFilePath": "Example/ExamplesPureMVC/Controller/StartUPCommand.cs",
            "fileBytesLength": 591,
            "filePosition": 104299
        },
        {
            "isDir": true,
            "fileName": "TestPanel",
            "relativeFilePath": "Example/ExamplesPureMVC/TestPanel",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "Resources",
            "relativeFilePath": "Example/ExamplesPureMVC/TestPanel/Resources",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "testPanel.prefab",
            "relativeFilePath": "Example/ExamplesPureMVC/TestPanel/Resources/testPanel.prefab",
            "fileBytesLength": 8767,
            "filePosition": 104890
        },
        {
            "isDir": false,
            "fileName": "TestPanel.cs",
            "relativeFilePath": "Example/ExamplesPureMVC/TestPanel/TestPanel.cs",
            "fileBytesLength": 187,
            "filePosition": 113657
        },
        {
            "isDir": false,
            "fileName": "TestPanelMediator.cs",
            "relativeFilePath": "Example/ExamplesPureMVC/TestPanel/TestPanelMediator.cs",
            "fileBytesLength": 828,
            "filePosition": 113844
        },
        {
            "isDir": true,
            "fileName": "TestYesWindow",
            "relativeFilePath": "Example/ExamplesPureMVC/TestYesWindow",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "Resources",
            "relativeFilePath": "Example/ExamplesPureMVC/TestYesWindow/Resources",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "TestYesWindow.prefab",
            "relativeFilePath": "Example/ExamplesPureMVC/TestYesWindow/Resources/TestYesWindow.prefab",
            "fileBytesLength": 11272,
            "filePosition": 114672
        },
        {
            "isDir": false,
            "fileName": "TestYesWindow.cs",
            "relativeFilePath": "Example/ExamplesPureMVC/TestYesWindow/TestYesWindow.cs",
            "fileBytesLength": 192,
            "filePosition": 125944
        },
        {
            "isDir": false,
            "fileName": "TestYesWindowMediator.cs",
            "relativeFilePath": "Example/ExamplesPureMVC/TestYesWindow/TestYesWindowMediator.cs",
            "fileBytesLength": 1529,
            "filePosition": 126136
        },
        {
            "isDir": false,
            "fileName": "App.cs",
            "relativeFilePath": "Example/ExamplesPureMVC/App.cs",
            "fileBytesLength": 489,
            "filePosition": 127665
        },
        {
            "isDir": false,
            "fileName": "AppFacade.cs",
            "relativeFilePath": "Example/ExamplesPureMVC/AppFacade.cs",
            "fileBytesLength": 1339,
            "filePosition": 128154
        },
        {
            "isDir": false,
            "fileName": "ExamplesPureMVC.unity",
            "relativeFilePath": "Example/ExamplesPureMVC/ExamplesPureMVC.unity",
            "fileBytesLength": 13867,
            "filePosition": 129493
        },
        {
            "isDir": true,
            "fileName": "Lua",
            "relativeFilePath": "Lua",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "org",
            "relativeFilePath": "Lua/org",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "puremvc",
            "relativeFilePath": "Lua/org/puremvc",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "lua",
            "relativeFilePath": "Lua/org/puremvc/lua",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "multicore",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "core",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/core",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "Controller.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/core/Controller.lua",
            "fileBytesLength": 5853,
            "filePosition": 143360
        },
        {
            "isDir": false,
            "fileName": "Model.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/core/Model.lua",
            "fileBytesLength": 3737,
            "filePosition": 149213
        },
        {
            "isDir": false,
            "fileName": "View.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/core/View.lua",
            "fileBytesLength": 7351,
            "filePosition": 152950
        },
        {
            "isDir": true,
            "fileName": "help",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/help",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "oop.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/help/oop.lua",
            "fileBytesLength": 1483,
            "filePosition": 160301
        },
        {
            "isDir": true,
            "fileName": "patterns",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": true,
            "fileName": "command",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/command",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "MacroCommand.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/command/MacroCommand.lua",
            "fileBytesLength": 2900,
            "filePosition": 161784
        },
        {
            "isDir": false,
            "fileName": "SimpleCommand.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/command/SimpleCommand.lua",
            "fileBytesLength": 1171,
            "filePosition": 164684
        },
        {
            "isDir": true,
            "fileName": "facade",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/facade",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "Facade.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/facade/Facade.lua",
            "fileBytesLength": 10924,
            "filePosition": 165855
        },
        {
            "isDir": true,
            "fileName": "mediator",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/mediator",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "Mediator.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/mediator/Mediator.lua",
            "fileBytesLength": 3843,
            "filePosition": 176779
        },
        {
            "isDir": true,
            "fileName": "observer",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/observer",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "Notification.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/observer/Notification.lua",
            "fileBytesLength": 2938,
            "filePosition": 180622
        },
        {
            "isDir": false,
            "fileName": "Notifier.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/observer/Notifier.lua",
            "fileBytesLength": 3200,
            "filePosition": 183560
        },
        {
            "isDir": false,
            "fileName": "Observer.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/observer/Observer.lua",
            "fileBytesLength": 2596,
            "filePosition": 186760
        },
        {
            "isDir": true,
            "fileName": "proxy",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/proxy",
            "fileBytesLength": -1,
            "filePosition": -1
        },
        {
            "isDir": false,
            "fileName": "Proxy.lua",
            "relativeFilePath": "Lua/org/puremvc/lua/multicore/patterns/proxy/Proxy.lua",
            "fileBytesLength": 1948,
            "filePosition": 189356
        },
        {
            "isDir": false,
            "fileName": "kitPackageConfig.json",
            "relativeFilePath": "kitPackageConfig.json",
            "fileBytesLength": 418,
            "filePosition": 191304
        }
    ]
}     D  kkp@v1.0.0;make by ks